(function () {
	'use strict';

	var workerCode = "(function () {\n\t'use strict';\n\n\t/**\r\n\t * Run-Length Encoding for numerical data.\r\n\t */\r\n\r\n\tclass RunLengthEncoding {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new container for Run-Length encoded data.\r\n\t\t *\r\n\t\t * @param {Number[]} [runLengths=null] - The run lengths.\r\n\t\t * @param {Number[]} [data=null] - The encoded data.\r\n\t\t */\r\n\r\n\t\tconstructor(runLengths = null, data = null) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The run lengths.\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.runLengths = runLengths;\r\n\r\n\t\t\t/**\r\n\t\t\t * The encoded data.\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = data;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Encodes the given data.\r\n\t\t *\r\n\t\t * @param {Number[]} array - The data to encode.\r\n\t\t * @return {RunLengthEncoding} The run-lengths and the encoded data.\r\n\t\t */\r\n\r\n\t\tstatic encode(array) {\r\n\r\n\t\t\tconst runLengths = [];\r\n\t\t\tconst data = [];\r\n\r\n\t\t\tlet previous = array[0];\r\n\t\t\tlet count = 1;\r\n\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 1, l = array.length; i < l; ++i) {\r\n\r\n\t\t\t\tif(previous !== array[i]) {\r\n\r\n\t\t\t\t\trunLengths.push(count);\r\n\t\t\t\t\tdata.push(previous);\r\n\r\n\t\t\t\t\tprevious = array[i];\r\n\t\t\t\t\tcount = 1;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t++count;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\trunLengths.push(count);\r\n\t\t\tdata.push(previous);\r\n\r\n\t\t\treturn new RunLengthEncoding(runLengths, data);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Decodes the given data.\r\n\t\t *\r\n\t\t * @param {Number[]} runLengths - The run-lengths.\r\n\t\t * @param {Number[]} data - The data to decode.\r\n\t\t * @param {Array} [array] - An optional target.\r\n\t\t * @return {Array} The decoded data.\r\n\t\t */\r\n\r\n\t\tstatic decode(runLengths, data, array = []) {\r\n\r\n\t\t\tlet element;\r\n\r\n\t\t\tlet i, j, il, jl;\r\n\t\t\tlet k = 0;\r\n\r\n\t\t\tfor(i = 0, il = data.length; i < il; ++i) {\r\n\r\n\t\t\t\telement = data[i];\r\n\r\n\t\t\t\tfor(j = 0, jl = runLengths[i]; j < jl; ++j) {\r\n\r\n\t\t\t\t\tarray[k++] = element;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Data compression and encoding components.\r\n\t *\r\n\t * @module rabbit-hole/compression\r\n\t */\n\n\t/**\r\n\t * A basic event.\r\n\t *\r\n\t * @param {String} type - The name of the event.\r\n\t */\r\n\r\n\tclass Event {\r\n\r\n\t\tconstructor(type) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The name of the event.\r\n\t\t\t *\r\n\t\t\t * @type {String}\r\n\t\t\t */\r\n\r\n\t\t\tthis.type = type;\r\n\r\n\t\t\t/**\r\n\t\t\t * A reference to the target to which the event was originally dispatched.\r\n\t\t\t *\r\n\t\t\t * @type {Object}\r\n\t\t\t * @default null\r\n\t\t\t */\r\n\r\n\t\t\tthis.target = null;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A base class for objects that can receive events and may have listeners for\r\n\t * them.\r\n\t */\n\n\t/**\r\n\t * A collection of event classes.\r\n\t *\r\n\t * @module synthetic-event\r\n\t */\n\n\t/**\r\n\t * An SDF loader event.\r\n\t */\r\n\r\n\tclass SDFLoaderEvent extends Event {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new SDF loader event.\r\n\t\t *\r\n\t\t * @param {String} type - The name of the event.\r\n\t\t */\r\n\r\n\t\tconstructor(type) {\r\n\r\n\t\t\tsuper(type);\r\n\r\n\t\t\t/**\r\n\t\t\t * A list of serialised SDFs.\r\n\t\t\t *\r\n\t\t\t * @type {Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.descriptions = null;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A terrain event.\r\n\t */\n\n\t/**\r\n\t * A worker event.\r\n\t */\r\n\r\n\tclass WorkerEvent extends Event {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new worker event.\r\n\t\t *\r\n\t\t * @param {String} type - The name of the event.\r\n\t\t */\r\n\r\n\t\tconstructor(type) {\r\n\r\n\t\t\tsuper(type);\r\n\r\n\t\t\t/**\r\n\t\t\t * A worker.\r\n\t\t\t *\r\n\t\t\t * @type {Worker}\r\n\t\t\t */\r\n\r\n\t\t\tthis.worker = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A worker response.\r\n\t\t\t *\r\n\t\t\t * @type {Response}\r\n\t\t\t */\r\n\r\n\t\t\tthis.response = null;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A collection of events.\r\n\t *\r\n\t * @module rabbit-hole/events\r\n\t */\n\n\t/**\r\n\t * A vector with three components.\r\n\t */\r\n\r\n\tclass Vector3 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new vector.\r\n\t\t *\r\n\t\t * @param {Number} [x=0] - The X component.\r\n\t\t * @param {Number} [y=0] - The Y component.\r\n\t\t * @param {Number} [z=0] - The Z component.\r\n\t\t */\r\n\r\n\t\tconstructor(x = 0, y = 0, z = 0) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The X component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.x = x;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Y component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.y = y;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Z component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.z = z;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this vector\r\n\t\t *\r\n\t\t * @param {Number} x - The X component.\r\n\t\t * @param {Number} y - The Y component.\r\n\t\t * @param {Number} z - The Z component.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tset(x, y, z) {\r\n\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of another vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tcopy(v) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this vector.\r\n\t\t *\r\n\t\t * @return {Vector3} A clone of this vector.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor(this.x, this.y, this.z);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies values from an array.\r\n\t\t *\r\n\t\t * @param {Number[]} array - An array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tfromArray(array, offset = 0) {\r\n\r\n\t\t\tthis.x = array[offset];\r\n\t\t\tthis.y = array[offset + 1];\r\n\t\t\tthis.z = array[offset + 2];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores this vector in an array.\r\n\t\t *\r\n\t\t * @param {Array} [array] - A target array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Number[]} The array.\r\n\t\t */\r\n\r\n\t\ttoArray(array = [], offset = 0) {\r\n\r\n\t\t\tarray[offset] = this.x;\r\n\t\t\tarray[offset + 1] = this.y;\r\n\t\t\tarray[offset + 2] = this.z;\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this vector based on a spherical description.\r\n\t\t *\r\n\t\t * @param {Spherical} s - A spherical description.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsetFromSpherical(s) {\r\n\r\n\t\t\tconst sinPhiRadius = Math.sin(s.phi) * s.radius;\r\n\r\n\t\t\tthis.x = sinPhiRadius * Math.sin(s.theta);\r\n\t\t\tthis.y = Math.cos(s.phi) * s.radius;\r\n\t\t\tthis.z = sinPhiRadius * Math.cos(s.theta);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this vector based on a cylindrical description.\r\n\t\t *\r\n\t\t * @param {Cylindrical} c - A cylindrical description.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsetFromCylindrical(c) {\r\n\r\n\t\t\tthis.x = c.radius * Math.sin(c.theta);\r\n\t\t\tthis.y = c.y;\r\n\t\t\tthis.z = c.radius * Math.cos(c.theta);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of a matrix column.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A 4x4 matrix.\r\n\t\t * @param {Number} index - A column index of the range [0, 2].\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsetFromMatrixColumn(m, index) {\r\n\r\n\t\t\treturn this.fromArray(m.elements, index * 4);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Extracts the position from a matrix.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A 4x4 matrix.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsetFromMatrixPosition(m) {\r\n\r\n\t\t\tconst me = m.elements;\r\n\r\n\t\t\tthis.x = me[12];\r\n\t\t\tthis.y = me[13];\r\n\t\t\tthis.z = me[14];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Extracts the scale from a matrix.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A 4x4 matrix.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsetFromMatrixScale(m) {\r\n\r\n\t\t\tconst sx = this.setFromMatrixColumn(m, 0).length();\r\n\t\t\tconst sy = this.setFromMatrixColumn(m, 1).length();\r\n\t\t\tconst sz = this.setFromMatrixColumn(m, 2).length();\r\n\r\n\t\t\tthis.x = sx;\r\n\t\t\tthis.y = sy;\r\n\t\t\tthis.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a vector to this one.\r\n\t\t *\r\n\t\t * @param {Vector3} v - The vector to add.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tadd(v) {\r\n\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a scalar to this vector.\r\n\t\t *\r\n\t\t * @param {Number} s - The scalar to add.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\taddScalar(s) {\r\n\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the sum of two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector3} a - A vector.\r\n\t\t * @param {Vector3} b - Another vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\taddVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a scaled vector to this one.\r\n\t\t *\r\n\t\t * @param {Vector3} v - The vector to scale and add.\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\taddScaledVector(v, s) {\r\n\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\t\tthis.z += v.z * s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts a vector from this vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - The vector to subtract.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsub(v) {\r\n\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts a scalar from this vector.\r\n\t\t *\r\n\t\t * @param {Number} s - The scalar to subtract.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsubScalar(s) {\r\n\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the difference between two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector3} a - A vector.\r\n\t\t * @param {Vector3} b - A second vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsubVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this vector with another vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tmultiply(v) {\r\n\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\t\tthis.z *= v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this vector with a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tmultiplyScalar(s) {\r\n\r\n\t\t\tthis.x *= s;\r\n\t\t\tthis.y *= s;\r\n\t\t\tthis.z *= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the product of two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector3} a - A vector.\r\n\t\t * @param {Vector3} b - Another vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tmultiplyVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x * b.x;\r\n\t\t\tthis.y = a.y * b.y;\r\n\t\t\tthis.z = a.z * b.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Divides this vector by another vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tdivide(v) {\r\n\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\t\tthis.z /= v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Divides this vector by a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tdivideScalar(s) {\r\n\r\n\t\t\tthis.x /= s;\r\n\t\t\tthis.y /= s;\r\n\t\t\tthis.z /= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the cross product of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tcross(v) {\r\n\r\n\t\t\tconst x = this.x, y = this.y, z = this.z;\r\n\r\n\t\t\tthis.x = y * v.z - z * v.y;\r\n\t\t\tthis.y = z * v.x - x * v.z;\r\n\t\t\tthis.z = x * v.y - y * v.x;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the cross product of the given vectors.\r\n\t\t *\r\n\t\t * @param {Vector3} a - A vector.\r\n\t\t * @param {Vector3} b - Another vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tcrossVectors(a, b) {\r\n\r\n\t\t\tconst ax = a.x, ay = a.y, az = a.z;\r\n\t\t\tconst bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\t\tthis.x = ay * bz - az * by;\r\n\t\t\tthis.y = az * bx - ax * bz;\r\n\t\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies a matrix to this direction vector.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\ttransformDirection(m) {\r\n\r\n\t\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\t\tconst e = m.elements;\r\n\r\n\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z;\r\n\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z;\r\n\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\r\n\r\n\t\t\treturn this.normalize();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies a matrix to this vector.\r\n\t\t *\r\n\t\t * @param {Matrix3} m - A matrix.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tapplyMatrix3(m) {\r\n\r\n\t\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\t\tconst e = m.elements;\r\n\r\n\t\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\r\n\t\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\r\n\t\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies a matrix to this vector.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tapplyMatrix4(m) {\r\n\r\n\t\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\t\tconst e = m.elements;\r\n\r\n\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12];\r\n\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13];\r\n\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies a quaternion to this vector.\r\n\t\t *\r\n\t\t * @param {Quaternion} q - A quaternion.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tapplyQuaternion(q) {\r\n\r\n\t\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\r\n\r\n\t\t\t// Calculate: quaternion * vector.\r\n\t\t\tconst ix = qw * x + qy * z - qz * y;\r\n\t\t\tconst iy = qw * y + qz * x - qx * z;\r\n\t\t\tconst iz = qw * z + qx * y - qy * x;\r\n\t\t\tconst iw = -qx * x - qy * y - qz * z;\r\n\r\n\t\t\t// Calculate: result * inverse quaternion.\r\n\t\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n\t\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n\t\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Negates this vector.\r\n\t\t *\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tnegate() {\r\n\r\n\t\t\tthis.x = -this.x;\r\n\t\t\tthis.y = -this.y;\r\n\t\t\tthis.z = -this.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the dot product with another vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Number} The dot product.\r\n\t\t */\r\n\r\n\t\tdot(v) {\r\n\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Reflects this vector. The given plane normal is assumed to be normalized.\r\n\t\t *\r\n\t\t * @param {Vector3} n - A normal.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\treflect(n, target = new Vector3()) {\r\n\r\n\t\t\tconst nx = n.x;\r\n\t\t\tconst ny = n.y;\r\n\t\t\tconst nz = n.z;\r\n\r\n\t\t\tthis.sub(n.multiplyScalar(2 * this.dot(n)));\r\n\r\n\t\t\t// Restore the normal.\r\n\t\t\tn.set(nx, ny, nz);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the angle to the given vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Number} The angle in radians.\r\n\t\t */\r\n\r\n\t\tangleTo(v) {\r\n\r\n\t\t\tconst theta = this.dot(v) / (Math.sqrt(this.lengthSquared() * v.lengthSquared()));\r\n\r\n\t\t\t// Clamp to avoid numerical problems.\r\n\t\t\treturn Math.acos(Math.min(Math.max(theta, -1), 1));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Manhattan length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tmanhattanLength() {\r\n\r\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The squared length.\r\n\t\t */\r\n\r\n\t\tlengthSquared() {\r\n\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tlength() {\r\n\r\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Manhattan distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tmanhattanDistanceTo(v) {\r\n\r\n\t\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Number} The squared distance.\r\n\t\t */\r\n\r\n\t\tdistanceToSquared(v) {\r\n\r\n\t\t\tconst dx = this.x - v.x;\r\n\t\t\tconst dy = this.y - v.y;\r\n\t\t\tconst dz = this.z - v.z;\r\n\r\n\t\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tdistanceTo(v) {\r\n\r\n\t\t\treturn Math.sqrt(this.distanceToSquared(v));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Normalizes this vector.\r\n\t\t *\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tnormalize() {\r\n\r\n\t\t\treturn this.divideScalar(this.length());\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the length of this vector.\r\n\t\t *\r\n\t\t * @param {Number} length - The new length.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tsetLength(length) {\r\n\r\n\t\t\treturn this.normalize().multiplyScalar(length);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the min value for each component of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tmin(v) {\r\n\r\n\t\t\tthis.x = Math.min(this.x, v.x);\r\n\t\t\tthis.y = Math.min(this.y, v.y);\r\n\t\t\tthis.z = Math.min(this.z, v.z);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the max value for each component of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tmax(v) {\r\n\r\n\t\t\tthis.x = Math.max(this.x, v.x);\r\n\t\t\tthis.y = Math.max(this.y, v.y);\r\n\t\t\tthis.z = Math.max(this.z, v.z);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clamps this vector.\r\n\t\t *\r\n\t\t * @param {Vector3} min - The lower bounds. Assumed to be smaller than max.\r\n\t\t * @param {Vector3} max - The upper bounds. Assumed to be greater than min.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tclamp(min, max) {\r\n\r\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\r\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\r\n\t\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Floors this vector.\r\n\t\t *\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tfloor() {\r\n\r\n\t\t\tthis.x = Math.floor(this.x);\r\n\t\t\tthis.y = Math.floor(this.y);\r\n\t\t\tthis.z = Math.floor(this.z);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Ceils this vector.\r\n\t\t *\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tceil() {\r\n\r\n\t\t\tthis.x = Math.ceil(this.x);\r\n\t\t\tthis.y = Math.ceil(this.y);\r\n\t\t\tthis.z = Math.ceil(this.z);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rounds this vector.\r\n\t\t *\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tround() {\r\n\r\n\t\t\tthis.x = Math.round(this.x);\r\n\t\t\tthis.y = Math.round(this.y);\r\n\t\t\tthis.z = Math.round(this.z);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Lerps towards the given vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - The target vector.\r\n\t\t * @param {Number} alpha - The lerp factor.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tlerp(v, alpha) {\r\n\r\n\t\t\tthis.x += (v.x - this.x) * alpha;\r\n\t\t\tthis.y += (v.y - this.y) * alpha;\r\n\t\t\tthis.z += (v.z - this.z) * alpha;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the lerp result of the given vectors.\r\n\t\t *\r\n\t\t * @param {Vector3} v1 - A base vector.\r\n\t\t * @param {Vector3} v2 - The target vector.\r\n\t\t * @param {Number} alpha - The lerp factor.\r\n\t\t * @return {Vector3} This vector.\r\n\t\t */\r\n\r\n\t\tlerpVectors(v1, v2, alpha) {\r\n\r\n\t\t\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this vector equals the given one.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Boolean} Whether this vector equals the given one.\r\n\t\t */\r\n\r\n\t\tequals(v) {\r\n\r\n\t\t\treturn (v.x === this.x && v.y === this.y && v.z === this.z);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst v$1 = new Vector3();\r\n\r\n\t/**\r\n\t * A 3D box.\r\n\t */\r\n\r\n\tclass Box3 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new box.\r\n\t\t *\r\n\t\t * @param {Vector3} [min] - The lower bounds.\r\n\t\t * @param {Vector3} [max] - The upper bounds.\r\n\t\t */\r\n\r\n\t\tconstructor(\r\n\t\t\tmin = new Vector3(Infinity, Infinity, Infinity),\r\n\t\t\tmax = new Vector3(-Infinity, -Infinity, -Infinity)\r\n\t\t) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The lower bounds.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.min = min;\r\n\r\n\t\t\t/**\r\n\t\t\t * The upper bounds.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.max = max;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this box.\r\n\t\t *\r\n\t\t * @param {Vector3} min - The lower bounds.\r\n\t\t * @param {Vector3} max - The upper bounds.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tset(min, max) {\r\n\r\n\t\t\tthis.min.copy(min);\r\n\t\t\tthis.max.copy(max);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of a given box.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tcopy(b) {\r\n\r\n\t\t\tthis.min.copy(b.min);\r\n\t\t\tthis.max.copy(b.max);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this box.\r\n\t\t *\r\n\t\t * @return {Box3} A clone of this box.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().copy(this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Makes this box empty.\r\n\t\t *\r\n\t\t * The lower bounds are set to infinity and the upper bounds to negative\r\n\t\t * infinity to create an infinitely small box.\r\n\t\t *\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tmakeEmpty() {\r\n\r\n\t\t\tthis.min.x = this.min.y = this.min.z = Infinity;\r\n\t\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Indicates whether this box is truly empty.\r\n\t\t *\r\n\t\t * This is a more robust check for emptiness since the volume can get positive\r\n\t\t * with two negative axes.\r\n\t\t *\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tisEmpty() {\r\n\r\n\t\t\treturn (\r\n\t\t\t\tthis.max.x < this.min.x ||\r\n\t\t\t\tthis.max.y < this.min.y ||\r\n\t\t\t\tthis.max.z < this.min.z\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the center of this box.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the center of this box.\r\n\t\t */\r\n\r\n\t\tgetCenter(target = new Vector3()) {\r\n\r\n\t\t\treturn !this.isEmpty() ?\r\n\t\t\t\ttarget.addVectors(this.min, this.max).multiplyScalar(0.5) :\r\n\t\t\t\ttarget.set(0, 0, 0);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the size of this box.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the size of this box.\r\n\t\t */\r\n\r\n\t\tgetSize(target = new Vector3()) {\r\n\r\n\t\t\treturn !this.isEmpty() ?\r\n\t\t\t\ttarget.subVectors(this.max, this.min) :\r\n\t\t\t\ttarget.set(0, 0, 0);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the bounding sphere of this box.\r\n\t\t *\r\n\t\t * @param {Sphere} [target] - A target sphere. If none is provided, a new one will be created.\r\n\t\t * @return {Sphere} The bounding sphere of this box.\r\n\t\t */\r\n\r\n\t\tgetBoundingSphere(target = new Sphere()) {\r\n\r\n\t\t\tthis.getCenter(target.center);\r\n\r\n\t\t\ttarget.radius = this.getSize(v$1).length() * 0.5;\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Expands this box by the given point.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\texpandByPoint(p) {\r\n\r\n\t\t\tthis.min.min(p);\r\n\t\t\tthis.max.max(p);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Expands this box by the given vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - A vector.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\texpandByVector(v) {\r\n\r\n\t\t\tthis.min.sub(v);\r\n\t\t\tthis.max.add(v);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Expands this box by the given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\texpandByScalar(s) {\r\n\r\n\t\t\tthis.min.addScalar(-s);\r\n\t\t\tthis.max.addScalar(s);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Defines this box by the given points.\r\n\t\t *\r\n\t\t * @param {Vector3[]} points - The points.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tsetFromPoints(points) {\r\n\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tthis.min.set(0, 0, 0);\r\n\t\t\tthis.max.set(0, 0, 0);\r\n\r\n\t\t\tfor(i = 0, l = points.length; i < l; ++i) {\r\n\r\n\t\t\t\tthis.expandByPoint(points[i]);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Defines this box by the given center and size.\r\n\t\t *\r\n\t\t * @param {Vector3} center - The center.\r\n\t\t * @param {Number} size - The size.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tsetFromCenterAndSize(center, size) {\r\n\r\n\t\t\tconst halfSize = v$1.copy(size).multiplyScalar(0.5);\r\n\r\n\t\t\tthis.min.copy(center).sub(halfSize);\r\n\t\t\tthis.max.copy(center).add(halfSize);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clamps the given point to the boundaries of this box.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The clamped point.\r\n\t\t */\r\n\r\n\t\tclampPoint(point, target = new Vector3()) {\r\n\r\n\t\t\treturn target.copy(point).clamp(this.min, this.max);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance from this box to the given point.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tdistanceToPoint(p) {\r\n\r\n\t\t\tconst clampedPoint = v$1.copy(p).clamp(this.min, this.max);\r\n\r\n\t\t\treturn clampedPoint.sub(p).length();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Translates this box.\r\n\t\t *\r\n\t\t * @param {Vector3} offset - The offset.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\ttranslate(offset) {\r\n\r\n\t\t\tthis.min.add(offset);\r\n\t\t\tthis.max.add(offset);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Intersects this box with the given one.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tintersect(b) {\r\n\r\n\t\t\tthis.min.max(b.min);\r\n\t\t\tthis.max.min(b.max);\r\n\r\n\t\t\t/* Ensure that if there is no overlap, the result is fully empty to prevent\r\n\t\t\tsubsequent intersections to erroneously return valid values. */\r\n\t\t\tif(this.isEmpty()) { this.makeEmpty(); }\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Expands this box by combining it with the given one.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Box3} This box.\r\n\t\t */\r\n\r\n\t\tunion(b) {\r\n\r\n\t\t\tthis.min.min(b.min);\r\n\t\t\tthis.max.max(b.max);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if the given point lies inside this box.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @return {Boolean} Whether this box contains the point.\r\n\t\t */\r\n\r\n\t\tcontainsPoint(p) {\r\n\r\n\t\t\tconst min = this.min;\r\n\t\t\tconst max = this.max;\r\n\r\n\t\t\treturn (\r\n\t\t\t\tp.x >= min.x &&\r\n\t\t\t\tp.y >= min.y &&\r\n\t\t\t\tp.z >= min.z &&\r\n\t\t\t\tp.x <= max.x &&\r\n\t\t\t\tp.y <= max.y &&\r\n\t\t\t\tp.z <= max.z\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if the given box lies inside this box.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Boolean} Whether this box contains the given one.\r\n\t\t */\r\n\r\n\t\tcontainsBox(b) {\r\n\r\n\t\t\tconst tMin = this.min;\r\n\t\t\tconst tMax = this.max;\r\n\t\t\tconst bMin = b.min;\r\n\t\t\tconst bMax = b.max;\r\n\r\n\t\t\treturn (\r\n\t\t\t\ttMin.x <= bMin.x && bMax.x <= tMax.x &&\r\n\t\t\t\ttMin.y <= bMin.y && bMax.y <= tMax.y &&\r\n\t\t\t\ttMin.z <= bMin.z && bMax.z <= tMax.z\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this box intersects the given one.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Boolean} Whether the boxes intersect.\r\n\t\t */\r\n\r\n\t\tintersectsBox(b) {\r\n\r\n\t\t\tconst tMin = this.min;\r\n\t\t\tconst tMax = this.max;\r\n\t\t\tconst bMin = b.min;\r\n\t\t\tconst bMax = b.max;\r\n\r\n\t\t\treturn (\r\n\t\t\t\tbMax.x >= tMin.x &&\r\n\t\t\t\tbMax.y >= tMin.y &&\r\n\t\t\t\tbMax.z >= tMin.z &&\r\n\t\t\t\tbMin.x <= tMax.x &&\r\n\t\t\t\tbMin.y <= tMax.y &&\r\n\t\t\t\tbMin.z <= tMax.z\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this box intersects the given sphere.\r\n\t\t *\r\n\t\t * @param {Sphere} s - A sphere.\r\n\t\t * @return {Boolean} Whether the box intersects the sphere.\r\n\t\t */\r\n\r\n\t\tintersectsSphere(s) {\r\n\r\n\t\t\t// Find the point in this box that is closest to the sphere's center.\r\n\t\t\tconst closestPoint = this.clampPoint(s.center, v$1);\r\n\r\n\t\t\t// If that point is inside the sphere, it intersects this box.\r\n\t\t\treturn (closestPoint.distanceToSquared(s.center) <= (s.radius * s.radius));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this box intersects the given plane.\r\n\t\t *\r\n\t\t * Computes the minimum and maximum dot product values. If those values are on\r\n\t\t * the same side (back or front) of the plane, then there is no intersection.\r\n\t\t *\r\n\t\t * @param {Plane} p - A plane.\r\n\t\t * @return {Boolean} Whether the box intersects the plane.\r\n\t\t */\r\n\r\n\t\tintersectsPlane(p) {\r\n\r\n\t\t\tlet min, max;\r\n\r\n\t\t\tif(p.normal.x > 0) {\r\n\r\n\t\t\t\tmin = p.normal.x * this.min.x;\r\n\t\t\t\tmax = p.normal.x * this.max.x;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmin = p.normal.x * this.max.x;\r\n\t\t\t\tmax = p.normal.x * this.min.x;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(p.normal.y > 0) {\r\n\r\n\t\t\t\tmin += p.normal.y * this.min.y;\r\n\t\t\t\tmax += p.normal.y * this.max.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmin += p.normal.y * this.max.y;\r\n\t\t\t\tmax += p.normal.y * this.min.y;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(p.normal.z > 0) {\r\n\r\n\t\t\t\tmin += p.normal.z * this.min.z;\r\n\t\t\t\tmax += p.normal.z * this.max.z;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmin += p.normal.z * this.max.z;\r\n\t\t\t\tmax += p.normal.z * this.min.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn (min <= p.constant && max >= p.constant);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this box equals the given one.\r\n\t\t *\r\n\t\t * @param {Box3} v - A box.\r\n\t\t * @return {Boolean} Whether this box equals the given one.\r\n\t\t */\r\n\r\n\t\tequals(b) {\r\n\r\n\t\t\treturn (b.min.equals(this.min) && b.max.equals(this.max));\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst box = new Box3();\r\n\r\n\t/**\r\n\t * A sphere.\r\n\t */\r\n\r\n\tclass Sphere {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new sphere.\r\n\t\t *\r\n\t\t * @param {Vector3} [center] - The center.\r\n\t\t * @param {Number} [radius] - The radius.\r\n\t\t */\r\n\r\n\t\tconstructor(center = new Vector3(), radius = 0) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The center.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.center = center;\r\n\r\n\t\t\t/**\r\n\t\t\t * The radius.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.radius = radius;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the center and the radius.\r\n\t\t *\r\n\t\t * @param {Vector3} center - The center.\r\n\t\t * @param {Number} radius - The radius.\r\n\t\t * @return {Sphere} This sphere.\r\n\t\t */\r\n\r\n\t\tset(center, radius) {\r\n\r\n\t\t\tthis.center.copy(center);\r\n\t\t\tthis.radius = radius;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the given sphere.\r\n\t\t *\r\n\t\t * @param {Sphere} s - A sphere.\r\n\t\t * @return {Sphere} This sphere.\r\n\t\t */\r\n\r\n\t\tcopy(s) {\r\n\r\n\t\t\tthis.center.copy(s.center);\r\n\t\t\tthis.radius = s.radius;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this sphere.\r\n\t\t *\r\n\t\t * @return {Sphere} The cloned sphere.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().copy(this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this sphere from points.\r\n\t\t *\r\n\t\t * @param {Vector3[]} points - The points.\r\n\t\t * @param {Vector3} [center] - An optional center.\r\n\t\t * @return {Sphere} This sphere.\r\n\t\t */\r\n\r\n\t\tsetFromPoints(points, center = box.setFromPoints(points).getCenter(this.center)) {\r\n\r\n\t\t\tlet maxRadiusSq = 0;\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 0, l = points.length; i < l; ++i) {\r\n\r\n\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.radius = Math.sqrt(maxRadiusSq);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the bounding box of this sphere.\r\n\t\t *\r\n\t\t * @param {Box3} [target] - A target sphere. If none is provided, a new one will be created.\r\n\t\t * @return {Box3} The bounding box.\r\n\t\t */\r\n\r\n\t\tgetBoundingBox(target = new Box3()) {\r\n\r\n\t\t\ttarget.set(this.center, this.center);\r\n\t\t\ttarget.expandByScalar(this.radius);\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this sphere is empty.\r\n\t\t *\r\n\t\t * @return {Boolean} Whether this sphere is empty.\r\n\t\t */\r\n\r\n\t\tisEmpty() {\r\n\r\n\t\t\treturn (this.radius <= 0);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Translates this sphere.\r\n\t\t *\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Sphere} This sphere.\r\n\t\t */\r\n\r\n\t\ttranslate(offset) {\r\n\r\n\t\t\tthis.center.add(offset);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clamps the given point to this sphere.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The clamped point.\r\n\t\t */\r\n\r\n\t\tclampPoint(p, target = new Vector3()) {\r\n\r\n\t\t\tconst deltaLengthSq = this.center.distanceToSquared(p);\r\n\r\n\t\t\ttarget.copy(p);\r\n\r\n\t\t\tif(deltaLengthSq > (this.radius * this.radius)) {\r\n\r\n\t\t\t\ttarget.sub(this.center).normalize();\r\n\t\t\t\ttarget.multiplyScalar(this.radius).add(this.center);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance from this sphere to the given point.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tdistanceToPoint(p) {\r\n\r\n\t\t\treturn (p.distanceTo(this.center) - this.radius);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if the given point lies inside this sphere.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @return {Boolean} Whether this sphere contains the point.\r\n\t\t */\r\n\r\n\t\tcontainsPoint(p) {\r\n\r\n\t\t\treturn (p.distanceToSquared(this.center) <= (this.radius * this.radius));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if the this sphere intersects with the given one.\r\n\t\t *\r\n\t\t * @param {Sphere} s - A sphere.\r\n\t\t * @return {Boolean} Whether this sphere intersects with the given one.\r\n\t\t */\r\n\r\n\t\tintersectsSphere(s) {\r\n\r\n\t\t\tconst radiusSum = this.radius + s.radius;\r\n\r\n\t\t\treturn s.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if the this sphere intersects with the given box.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Boolean} Whether this sphere intersects with the given box.\r\n\t\t */\r\n\r\n\t\tintersectsBox(b) {\r\n\r\n\t\t\treturn b.intersectsSphere(this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if the this sphere intersects with the given plane.\r\n\t\t *\r\n\t\t * @param {Plane} p - A plane.\r\n\t\t * @return {Boolean} Whether this sphere intersects with the given plane.\r\n\t\t */\r\n\r\n\t\tintersectsPlane(p) {\r\n\r\n\t\t\treturn (Math.abs(p.distanceToPoint(this.center)) <= this.radius);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this sphere equals the given one.\r\n\t\t *\r\n\t\t * @param {Sphere} s - A sphere.\r\n\t\t * @return {Boolean} Whether the spheres are equal.\r\n\t\t */\r\n\r\n\t\tequals(s) {\r\n\r\n\t\t\treturn (s.center.equals(this.center) && (s.radius === this.radius));\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A vector with two components.\r\n\t */\r\n\r\n\tclass Vector2 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new vector.\r\n\t\t *\r\n\t\t * @param {Number} [x=0] - The X component.\r\n\t\t * @param {Number} [y=0] - The Y component.\r\n\t\t */\r\n\r\n\t\tconstructor(x = 0, y = 0) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The X component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.x = x;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Y component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.y = y;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The width. This is an alias for X.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tget width() { return this.x; }\r\n\r\n\t\t/**\r\n\t\t * Sets the width.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tset width(value) { return this.x = value; }\r\n\r\n\t\t/**\r\n\t\t * The height. This is an alias for Y.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tget height() { return this.y; }\r\n\r\n\t\t/**\r\n\t\t * Sets the height.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tset height(value) { return this.y = value; }\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this vector\r\n\t\t *\r\n\t\t * @param {Number} x - The X component.\r\n\t\t * @param {Number} y - The Y component.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tset(x, y) {\r\n\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of another vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tcopy(v) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this vector.\r\n\t\t *\r\n\t\t * @return {Vector2} A clone of this vector.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor(this.x, this.y);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies values from an array.\r\n\t\t *\r\n\t\t * @param {Number[]} array - An array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tfromArray(array, offset = 0) {\r\n\r\n\t\t\tthis.x = array[offset];\r\n\t\t\tthis.y = array[offset + 1];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores this vector in an array.\r\n\t\t *\r\n\t\t * @param {Array} [array] - A target array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Number[]} The array.\r\n\t\t */\r\n\r\n\t\ttoArray(array = [], offset = 0) {\r\n\r\n\t\t\tarray[offset] = this.x;\r\n\t\t\tarray[offset + 1] = this.y;\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a vector to this one.\r\n\t\t *\r\n\t\t * @param {Vector2} v - The vector to add.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tadd(v) {\r\n\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a scalar to this vector.\r\n\t\t *\r\n\t\t * @param {Number} s - The scalar to add.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\taddScalar(s) {\r\n\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the sum of two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector2} a - A vector.\r\n\t\t * @param {Vector2} b - Another vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\taddVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a scaled vector to this one.\r\n\t\t *\r\n\t\t * @param {Vector2} v - The vector to scale and add.\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\taddScaledVector(v, s) {\r\n\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts a vector from this vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - The vector to subtract.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tsub(v) {\r\n\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts a scalar from this vector.\r\n\t\t *\r\n\t\t * @param {Number} s - The scalar to subtract.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tsubScalar(s) {\r\n\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the difference between two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector2} a - A vector.\r\n\t\t * @param {Vector2} b - A second vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tsubVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this vector with another vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tmultiply(v) {\r\n\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this vector with a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tmultiplyScalar(s) {\r\n\r\n\t\t\tthis.x *= s;\r\n\t\t\tthis.y *= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Divides this vector by another vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tdivide(v) {\r\n\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Divides this vector by a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tdivideScalar(s) {\r\n\r\n\t\t\tthis.x /= s;\r\n\t\t\tthis.y /= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies the given matrix to this vector.\r\n\t\t *\r\n\t\t * @param {Matrix3} m - A matrix.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tapplyMatrix3(m) {\r\n\r\n\t\t\tconst x = this.x, y = this.y;\r\n\t\t\tconst e = m.elements;\r\n\r\n\t\t\tthis.x = e[0] * x + e[3] * y + e[6];\r\n\t\t\tthis.y = e[1] * x + e[4] * y + e[7];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the dot product with another vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Number} The dot product.\r\n\t\t */\r\n\r\n\t\tdot(v) {\r\n\r\n\t\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Manhattan length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tmanhattanLength() {\r\n\r\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The squared length.\r\n\t\t */\r\n\r\n\t\tlengthSquared() {\r\n\r\n\t\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tlength() {\r\n\r\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Manhattan distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Number} The squared distance.\r\n\t\t */\r\n\r\n\t\tmanhattanDistanceTo(v) {\r\n\r\n\t\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Number} The squared distance.\r\n\t\t */\r\n\r\n\t\tdistanceToSquared(v) {\r\n\r\n\t\t\tconst dx = this.x - v.x;\r\n\t\t\tconst dy = this.y - v.y;\r\n\r\n\t\t\treturn dx * dx + dy * dy;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tdistanceTo(v) {\r\n\r\n\t\t\treturn Math.sqrt(this.distanceToSquared(v));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Normalizes this vector.\r\n\t\t *\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tnormalize() {\r\n\r\n\t\t\treturn this.divideScalar(this.length());\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the length of this vector.\r\n\t\t *\r\n\t\t * @param {Number} length - The new length.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tsetLength(length) {\r\n\r\n\t\t\treturn this.normalize().multiplyScalar(length);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the min value for each component of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tmin(v) {\r\n\r\n\t\t\tthis.x = Math.min(this.x, v.x);\r\n\t\t\tthis.y = Math.min(this.y, v.y);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * adopts the max value for each component of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tmax(v) {\r\n\r\n\t\t\tthis.x = Math.max(this.x, v.x);\r\n\t\t\tthis.y = Math.max(this.y, v.y);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clamps this vector.\r\n\t\t *\r\n\t\t * @param {Vector2} min - A vector, assumed to be smaller than max.\r\n\t\t * @param {Vector2} max - A vector, assumed to be greater than min.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tclamp(min, max) {\r\n\r\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\r\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Floors this vector.\r\n\t\t *\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tfloor() {\r\n\r\n\t\t\tthis.x = Math.floor(this.x);\r\n\t\t\tthis.y = Math.floor(this.y);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Ceils this vector.\r\n\t\t *\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tceil() {\r\n\r\n\t\t\tthis.x = Math.ceil(this.x);\r\n\t\t\tthis.y = Math.ceil(this.y);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rounds this vector.\r\n\t\t *\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tround() {\r\n\r\n\t\t\tthis.x = Math.round(this.x);\r\n\t\t\tthis.y = Math.round(this.y);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Negates this vector.\r\n\t\t *\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tnegate() {\r\n\r\n\t\t\tthis.x = -this.x;\r\n\t\t\tthis.y = -this.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the angle in radians with respect to the positive X-axis.\r\n\t\t *\r\n\t\t * @return {Number} The angle.\r\n\t\t */\r\n\r\n\t\tangle() {\r\n\r\n\t\t\tlet angle = Math.atan2(this.y, this.x);\r\n\r\n\t\t\tif(angle < 0) { angle += 2 * Math.PI; }\r\n\r\n\t\t\treturn angle;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Lerps towards the given vector.\r\n\t\t *\r\n\t\t * @param {Vector2} v - The target vector.\r\n\t\t * @param {Number} alpha - The lerp factor.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tlerp(v, alpha) {\r\n\r\n\t\t\tthis.x += (v.x - this.x) * alpha;\r\n\t\t\tthis.y += (v.y - this.y) * alpha;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the lerp result of the given vectors.\r\n\t\t *\r\n\t\t * @param {Vector2} v1 - A base vector.\r\n\t\t * @param {Vector2} v2 - The target vector.\r\n\t\t * @param {Number} alpha - The lerp factor.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\tlerpVectors(v1, v2, alpha) {\r\n\r\n\t\t\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rotates this vector around a given center.\r\n\t\t *\r\n\t\t * @param {Vector2} center - The center.\r\n\t\t * @param {Number} angle - The rotation in radians.\r\n\t\t * @return {Vector2} This vector.\r\n\t\t */\r\n\r\n\t\trotateAround(center, angle) {\r\n\r\n\t\t\tconst c = Math.cos(angle), s = Math.sin(angle);\r\n\r\n\t\t\tconst x = this.x - center.x;\r\n\t\t\tconst y = this.y - center.y;\r\n\r\n\t\t\tthis.x = x * c - y * s + center.x;\r\n\t\t\tthis.y = x * s + y * c + center.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this vector equals the given one.\r\n\t\t *\r\n\t\t * @param {Vector2} v - A vector.\r\n\t\t * @return {Boolean} Whether this vector equals the given one.\r\n\t\t */\r\n\r\n\t\tequals(v) {\r\n\r\n\t\t\treturn (v.x === this.x && v.y === this.y);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector2}\r\n\t * @private\r\n\t */\r\n\r\n\tconst v = new Vector2();\r\n\r\n\t/**\r\n\t * A 2D box.\r\n\t */\n\n\t/**\r\n\t * A cylindrical coordinate system.\r\n\t *\r\n\t * For details see: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\r\n\t */\n\n\t/**\r\n\t * A 3x3 matrix.\r\n\t */\r\n\r\n\tclass Matrix3 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new matrix.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\t/**\r\n\t\t\t * The matrix elements.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.elements = new Float32Array([\r\n\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t0, 1, 0,\r\n\t\t\t\t0, 0, 1\r\n\r\n\t\t\t]);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this matrix.\r\n\t\t *\r\n\t\t * @param {Number} m00 - The value of the first row, first column.\r\n\t\t * @param {Number} m01 - The value of the first row, second column.\r\n\t\t * @param {Number} m02 - The value of the first row, third column.\r\n\t\t * @param {Number} m10 - The value of the second row, first column.\r\n\t\t * @param {Number} m11 - The value of the second row, second column.\r\n\t\t * @param {Number} m12 - The value of the second row, third column.\r\n\t\t * @param {Number} m20 - The value of the third row, first column.\r\n\t\t * @param {Number} m21 - The value of the third row, second column.\r\n\t\t * @param {Number} m22 - The value of the third row, third column.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tset(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] = m00; te[3] = m01; te[6] = m02;\r\n\t\t\tte[1] = m10; te[4] = m11; te[7] = m12;\r\n\t\t\tte[2] = m20; te[5] = m21; te[8] = m22;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this matrix to the identity matrix.\r\n\t\t *\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tidentity() {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t0, 1, 0,\r\n\t\t\t\t0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of a given matrix.\r\n\t\t *\r\n\t\t * @param {Matrix3} matrix - A matrix.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tcopy(matrix) {\r\n\r\n\t\t\tconst me = matrix.elements;\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] = me[0]; te[1] = me[1]; te[2] = me[2];\r\n\t\t\tte[3] = me[3]; te[4] = me[4]; te[5] = me[5];\r\n\t\t\tte[6] = me[6]; te[7] = me[7]; te[8] = me[8];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this matrix.\r\n\t\t *\r\n\t\t * @return {Matrix3} A clone of this matrix.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().fromArray(this.elements);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of a given array.\r\n\t\t *\r\n\t\t * @param {Number[]} array - An array.\r\n\t\t * @param {Number} [offset=0] - An offset into the array.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tfromArray(array, offset = 0) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tlet i;\r\n\r\n\t\t\tfor(i = 0; i < 9; ++i) {\r\n\r\n\t\t\t\tte[i] = array[i + offset];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores this matrix in an array.\r\n\t\t *\r\n\t\t * @param {Number[]} [array] - A target array.\r\n\t\t * @param {Number} [offset=0] - An offset into the array.\r\n\t\t * @return {Number[]} The array.\r\n\t\t */\r\n\r\n\t\ttoArray(array = [], offset = 0) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tlet i;\r\n\r\n\t\t\tfor(i = 0; i < 9; ++i) {\r\n\r\n\t\t\t\tarray[i + offset] = te[i];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this matrix to the product of the given matrices.\r\n\t\t *\r\n\t\t * @param {Matrix3} a - A matrix.\r\n\t\t * @param {Matrix3} b - A matrix.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tmultiplyMatrices(a, b) {\r\n\r\n\t\t\tconst ae = a.elements;\r\n\t\t\tconst be = b.elements;\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst a11 = ae[0], a12 = ae[3], a13 = ae[6];\r\n\t\t\tconst a21 = ae[1], a22 = ae[4], a23 = ae[7];\r\n\t\t\tconst a31 = ae[2], a32 = ae[5], a33 = ae[8];\r\n\r\n\t\t\tconst b11 = be[0], b12 = be[3], b13 = be[6];\r\n\t\t\tconst b21 = be[1], b22 = be[4], b23 = be[7];\r\n\t\t\tconst b31 = be[2], b32 = be[5], b33 = be[8];\r\n\r\n\t\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31;\r\n\t\t\tte[3] = a11 * b12 + a12 * b22 + a13 * b32;\r\n\t\t\tte[6] = a11 * b13 + a12 * b23 + a13 * b33;\r\n\r\n\t\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31;\r\n\t\t\tte[4] = a21 * b12 + a22 * b22 + a23 * b32;\r\n\t\t\tte[7] = a21 * b13 + a22 * b23 + a23 * b33;\r\n\r\n\t\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31;\r\n\t\t\tte[5] = a31 * b12 + a32 * b22 + a33 * b32;\r\n\t\t\tte[8] = a31 * b13 + a32 * b23 + a33 * b33;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this matrix with a given one.\r\n\t\t *\r\n\t\t * @param {Matrix3} m - A matrix.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tmultiply(m) {\r\n\r\n\t\t\treturn this.multiplyMatrices(this, m);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies a given matrix with this one.\r\n\t\t *\r\n\t\t * @param {Matrix3} m - A matrix.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tpremultiply(m) {\r\n\r\n\t\t\treturn this.multiplyMatrices(m, this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this matrix with a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} m - A scalar.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tmultiplyScalar(s) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] *= s; te[3] *= s; te[6] *= s;\r\n\t\t\tte[1] *= s; te[4] *= s; te[7] *= s;\r\n\t\t\tte[2] *= s; te[5] *= s; te[8] *= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the determinant of this matrix.\r\n\t\t *\r\n\t\t * @return {Number} The determinant.\r\n\t\t */\r\n\r\n\t\tdeterminant() {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst a = te[0], b = te[1], c = te[2];\r\n\t\t\tconst d = te[3], e = te[4], f = te[5];\r\n\t\t\tconst g = te[6], h = te[7], i = te[8];\r\n\r\n\t\t\treturn (\r\n\r\n\t\t\t\ta * e * i -\r\n\t\t\t\ta * f * h -\r\n\t\t\t\tb * d * i +\r\n\t\t\t\tb * f * g +\r\n\t\t\t\tc * d * h -\r\n\t\t\t\tc * e * g\r\n\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Inverts the given matrix and stores the result in this matrix.\r\n\t\t *\r\n\t\t * @param {Matrix3} matrix - The matrix that should be inverted.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tgetInverse(matrix) {\r\n\r\n\t\t\tconst me = matrix.elements;\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst n11 = me[0], n21 = me[1], n31 = me[2];\r\n\t\t\tconst n12 = me[3], n22 = me[4], n32 = me[5];\r\n\t\t\tconst n13 = me[6], n23 = me[7], n33 = me[8];\r\n\r\n\t\t\tconst t11 = n33 * n22 - n32 * n23;\r\n\t\t\tconst t12 = n32 * n13 - n33 * n12;\r\n\t\t\tconst t13 = n23 * n12 - n22 * n13;\r\n\r\n\t\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13;\r\n\r\n\t\t\tlet invDet;\r\n\r\n\t\t\tif(det !== 0) {\r\n\r\n\t\t\t\tinvDet = 1.0 / det;\r\n\r\n\t\t\t\tte[0] = t11 * invDet;\r\n\t\t\t\tte[1] = (n31 * n23 - n33 * n21) * invDet;\r\n\t\t\t\tte[2] = (n32 * n21 - n31 * n22) * invDet;\r\n\r\n\t\t\t\tte[3] = t12 * invDet;\r\n\t\t\t\tte[4] = (n33 * n11 - n31 * n13) * invDet;\r\n\t\t\t\tte[5] = (n31 * n12 - n32 * n11) * invDet;\r\n\r\n\t\t\t\tte[6] = t13 * invDet;\r\n\t\t\t\tte[7] = (n21 * n13 - n23 * n11) * invDet;\r\n\t\t\t\tte[8] = (n22 * n11 - n21 * n12) * invDet;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error(\"Can't invert matrix, determinant is zero\", matrix);\r\n\r\n\t\t\t\tthis.identity();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Transposes this matrix.\r\n\t\t *\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\ttranspose() {\r\n\r\n\t\t\tconst me = this.elements;\r\n\r\n\t\t\tlet t;\r\n\r\n\t\t\tt = me[1]; me[1] = me[3]; me[3] = t;\r\n\t\t\tt = me[2]; me[2] = me[6]; me[6] = t;\r\n\t\t\tt = me[5]; me[5] = me[7]; me[7] = t;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Scales this matrix.\r\n\t\t *\r\n\t\t * @param {Number} sx - The X scale.\r\n\t\t * @param {Number} sy - The Y scale.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tscale(sx, sy) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] *= sx; te[3] *= sx; te[6] *= sx;\r\n\t\t\tte[1] *= sy; te[4] *= sy; te[7] *= sy;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rotates this matrix.\r\n\t\t *\r\n\t\t * @param {Number} theta - The rotation.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\trotate(theta) {\r\n\r\n\t\t\tconst c = Math.cos(theta);\r\n\t\t\tconst s = Math.sin(theta);\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tconst a11 = te[0], a12 = te[3], a13 = te[6];\r\n\t\t\tconst a21 = te[1], a22 = te[4], a23 = te[7];\r\n\r\n\t\t\tte[0] = c * a11 + s * a21;\r\n\t\t\tte[3] = c * a12 + s * a22;\r\n\t\t\tte[6] = c * a13 + s * a23;\r\n\r\n\t\t\tte[1] = -s * a11 + c * a21;\r\n\t\t\tte[4] = -s * a12 + c * a22;\r\n\t\t\tte[7] = -s * a13 + c * a23;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Translates this matrix.\r\n\t\t *\r\n\t\t * @param {Number} tx - The X offset.\r\n\t\t * @param {Number} ty - The Y offset.\r\n\t\t * @return {Matrix3} This matrix.\r\n\t\t */\r\n\r\n\t\ttranslate(tx, ty) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\r\n\t\t\tte[0] += tx * te[2]; te[3] += tx * te[5]; te[6] += tx * te[8];\r\n\t\t\tte[1] += ty * te[2]; te[4] += ty * te[5]; te[7] += ty * te[8];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this matrix equals the given one.\r\n\t\t *\r\n\t\t * @param {Matrix3} m - A matrix.\r\n\t\t * @return {Boolean} Whether the matrix are equal.\r\n\t\t */\r\n\r\n\t\tequals(matrix) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst me = matrix.elements;\r\n\r\n\t\t\tlet result = true;\r\n\t\t\tlet i;\r\n\r\n\t\t\tfor(i = 0; result && i < 9; ++i) {\r\n\r\n\t\t\t\tif(te[i] !== me[i]) {\r\n\r\n\t\t\t\t\tresult = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * An enumeration of Euler rotation orders.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {String} XYZ - X -> Y -> Z.\r\n\t * @property {String} YZX - Y -> Z -> X.\r\n\t * @property {String} ZXY - Z -> X -> Y.\r\n\t * @property {String} XZY - X -> Z -> Y.\r\n\t * @property {String} YXZ - Y -> X -> Z.\r\n\t * @property {String} ZYX - Z -> Y -> X.\r\n\t */\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst v$2 = new Vector3();\r\n\r\n\t/**\r\n\t * A quaternion.\r\n\t */\n\n\t/**\r\n\t * A matrix.\r\n\t *\r\n\t * @type {Matrix3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst m = new Matrix3();\r\n\r\n\t/**\r\n\t * Euler angles.\r\n\t */\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst a = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b = new Vector3();\r\n\r\n\t/**\r\n\t * A line.\r\n\t */\r\n\r\n\tclass Line3 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new line.\r\n\t\t *\r\n\t\t * @param {Vector3} [start] - The starting point. If none is provided, a new vector will be created.\r\n\t\t * @param {Vector3} [end] - The ending point. If none is provided, a new vector will be created.\r\n\t\t */\r\n\r\n\t\tconstructor(start = new Vector3(), end = new Vector3()) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The starting point.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.start = start;\r\n\r\n\t\t\t/**\r\n\t\t\t * The ending point.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.end = end;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the starting and ending point of this line.\r\n\t\t *\r\n\t\t * @param {Vector3} start - The starting point.\r\n\t\t * @param {Vector3} end - The ending point.\r\n\t\t * @return {Line3} This line.\r\n\t\t */\r\n\r\n\t\tset(start, end) {\r\n\r\n\t\t\tthis.start.copy(start);\r\n\t\t\tthis.end.copy(end);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of the given line.\r\n\t\t *\r\n\t\t * @param {Line3} l - A line.\r\n\t\t * @return {Line3} This line.\r\n\t\t */\r\n\r\n\t\tcopy(l) {\r\n\r\n\t\t\tthis.start.copy(l.start);\r\n\t\t\tthis.end.copy(l.end);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this line.\r\n\t\t *\r\n\t\t * @return {Line3} The cloned line.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().copy(this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the center of this line.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The center of this line.\r\n\t\t */\r\n\r\n\t\tgetCenter(target = new Vector3()) {\r\n\r\n\t\t\treturn target.addVectors(this.start, this.end).multiplyScalar(0.5);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the delta vector of this line.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The delta vector of this line.\r\n\t\t */\r\n\r\n\t\tdelta(target = new Vector3()) {\r\n\r\n\t\t\treturn target.subVectors(this.end, this.start);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared length of this line.\r\n\t\t *\r\n\t\t * @return {Vector3} The squared length.\r\n\t\t */\r\n\r\n\t\tlengthSquared() {\r\n\r\n\t\t\treturn this.start.distanceToSquared(this.end);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the length of this line.\r\n\t\t *\r\n\t\t * @return {Vector3} The length.\r\n\t\t */\r\n\r\n\t\tlength() {\r\n\r\n\t\t\treturn this.start.distanceTo(this.end);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adjusts this line to point in the given direction.\r\n\t\t *\r\n\t\t * @param {Vector3} d - The direction.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The length.\r\n\t\t */\r\n\r\n\t\tat(d, target) {\r\n\r\n\t\t\treturn this.delta(target).multiplyScalar(d).add(this.start);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns a point parameter based on the closest point as projected on the line segement.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @param {Boolean} clampToLine - Whether the point should be clamped to the line.\r\n\t\t * @return {Vector3} The parameter.\r\n\t\t */\r\n\r\n\t\tclosestPointToPointParameter(p, clampToLine) {\r\n\r\n\t\t\ta.subVectors(p, this.start);\r\n\t\t\tb.subVectors(this.end, this.start);\r\n\r\n\t\t\tconst bb = b.dot(b);\r\n\t\t\tconst ba = b.dot(a);\r\n\r\n\t\t\tconst t = clampToLine ? Math.min(Math.max(ba / bb, 0), 1) : ba / bb;\r\n\r\n\t\t\treturn t;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the closest point on the line.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @param {Boolean} [clampToLine=false] - Whether the point should be clamped to the line.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The parameter.\r\n\t\t */\r\n\r\n\t\tclosestPointToPoint(p, clampToLine = false, target = new Vector3()) {\r\n\r\n\t\t\tconst t = this.closestPointToPointParameter(p, clampToLine);\r\n\r\n\t\t\treturn this.delta(target).multiplyScalar(t).add(this.start);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this line equals the given one.\r\n\t\t *\r\n\t\t * @param {Line3} l - A line.\r\n\t\t * @return {Boolean} Whether the lines are equal.\r\n\t\t */\r\n\r\n\t\tequals(l) {\r\n\r\n\t\t\treturn l.start.equals(this.start) && l.end.equals(this.end);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst a$1 = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b$1 = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst c$1 = new Vector3();\r\n\r\n\t/**\r\n\t * A 4x4 matrix.\r\n\t */\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst a$2 = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b$2 = new Vector3();\r\n\r\n\t/**\r\n\t * A plane.\r\n\t */\n\n\t/**\r\n\t * A list of vectors.\r\n\t *\r\n\t * @type {Vector3[]}\r\n\t * @private\r\n\t */\r\n\r\n\tconst v$3 = [\r\n\t\tnew Vector3(),\r\n\t\tnew Vector3(),\r\n\t\tnew Vector3(),\r\n\t\tnew Vector3()\r\n\t];\r\n\r\n\t/**\r\n\t * A ray.\r\n\t */\r\n\r\n\tclass Ray {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new ray.\r\n\t\t *\r\n\t\t * @param {Vector3} [origin] - The origin.\r\n\t\t * @param {Vector3} [direction] - The direction.\r\n\t\t */\r\n\r\n\t\tconstructor(origin = new Vector3(), direction = new Vector3()) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The origin.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.origin = origin;\r\n\r\n\t\t\t/**\r\n\t\t\t * The direction.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.direction = direction;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the origin and the direction.\r\n\t\t *\r\n\t\t * @param {Vector3} origin - The origin.\r\n\t\t * @param {Vector3} direction - The direction. Should be normalized.\r\n\t\t * @return {Ray} This ray.\r\n\t\t */\r\n\r\n\t\tset(origin, direction) {\r\n\r\n\t\t\tthis.origin.copy(origin);\r\n\t\t\tthis.direction.copy(direction);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the given ray.\r\n\t\t *\r\n\t\t * @param {Ray} r - A ray.\r\n\t\t * @return {Ray} This ray.\r\n\t\t */\r\n\r\n\t\tcopy(r) {\r\n\r\n\t\t\tthis.origin.copy(r.origin);\r\n\t\t\tthis.direction.copy(r.direction);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this ray.\r\n\t\t *\r\n\t\t * @return {Ray} The cloned ray.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().copy(this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes a point along the ray based on a given scalar t.\r\n\t\t *\r\n\t\t * @param {Number} t - The scalar.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The point.\r\n\t\t */\r\n\r\n\t\tat(t, target = new Vector3()) {\r\n\r\n\t\t\treturn target.copy(this.direction).multiplyScalar(t).add(this.origin);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rotates this ray to look at the given target.\r\n\t\t *\r\n\t\t * @param {Vector3} target - A point to look at.\r\n\t\t * @return {Ray} This ray.\r\n\t\t */\r\n\r\n\t\tlookAt(target) {\r\n\r\n\t\t\tthis.direction.copy(target).sub(this.origin).normalize();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Moves the origin along the ray by a given scalar t.\r\n\t\t *\r\n\t\t * @param {Number} t - The scalar.\r\n\t\t * @return {Ray} This ray.\r\n\t\t */\r\n\r\n\t\trecast(t) {\r\n\r\n\t\t\tthis.origin.copy(this.at(t, v$3[0]));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds the closest point along this ray to a given point.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The point.\r\n\t\t */\r\n\r\n\t\tclosestPointToPoint(p, target = new Vector3()) {\r\n\r\n\t\t\tconst directionDistance = target.subVectors(p, this.origin).dot(this.direction);\r\n\r\n\t\t\treturn (directionDistance >= 0.0) ?\r\n\t\t\t\ttarget.copy(this.direction).multiplyScalar(directionDistance).add(this.origin) :\r\n\t\t\t\ttarget.copy(this.origin);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared distance from this ray to the given point.\r\n\t\t *\r\n\t\t * @param {Vector3} p - The point.\r\n\t\t * @return {Number} The squared distance.\r\n\t\t */\r\n\r\n\t\tdistanceSquaredToPoint(p) {\r\n\r\n\t\t\tconst directionDistance = v$3[0].subVectors(p, this.origin).dot(this.direction);\r\n\r\n\t\t\t// Check if the point is behind the ray.\r\n\t\t\treturn (directionDistance < 0.0) ?\r\n\t\t\t\tthis.origin.distanceToSquared(p) :\r\n\t\t\t\tv$3[0].copy(this.direction).multiplyScalar(directionDistance).add(this.origin).distanceToSquared(p);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance from this ray to the given point.\r\n\t\t *\r\n\t\t * @param {Vector3} p - The point.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tdistanceToPoint(p) {\r\n\r\n\t\t\treturn Math.sqrt(this.distanceSquaredToPoint(p));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance from this ray to the given plane.\r\n\t\t *\r\n\t\t * @param {Plane} p - The plane.\r\n\t\t * @return {Number} The distance, or null if the denominator is zero.\r\n\t\t */\r\n\r\n\t\tdistanceToPlane(p) {\r\n\r\n\t\t\tconst denominator = p.normal.dot(this.direction);\r\n\r\n\t\t\tconst t = (denominator !== 0.0) ?\r\n\t\t\t\t-(this.origin.dot(p.normal) + p.constant) / denominator :\r\n\t\t\t\t((p.distanceToPoint(this.origin) === 0.0) ? 0.0 : -1.0);\r\n\r\n\t\t\treturn (t >= 0.0) ? t : null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance from this ray to a given line segment.\r\n\t\t *\r\n\t\t * Based on:\r\n\t\t *  http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\r\n\t\t *\r\n\t\t * @param {Vector3} v0 - The start of the segment.\r\n\t\t * @param {Vector3} v1 - The end of the segment.\r\n\t\t * @param {Vector3} [pointOnRay] - If provided, the point on this Ray that is closest to the segment will be stored in this vector.\r\n\t\t * @param {Vector3} [pointOnSegment] - If provided, the point on the line segment that is closest to this ray will be stored in this vector.\r\n\t\t * @return {Number} The smallest distance between the ray and the segment defined by v0 and v1.\r\n\t\t */\r\n\r\n\t\tdistanceSquaredToSegment(v0, v1, pointOnRay, pointOnSegment) {\r\n\r\n\t\t\tconst segCenter = v$3[0].copy(v0).add(v1).multiplyScalar(0.5);\r\n\t\t\tconst segDir = v$3[1].copy(v1).sub(v0).normalize();\r\n\t\t\tconst diff = v$3[2].copy(this.origin).sub(segCenter);\r\n\r\n\t\t\tconst segExtent = v0.distanceTo(v1) * 0.5;\r\n\t\t\tconst a01 = -this.direction.dot(segDir);\r\n\t\t\tconst b0 = diff.dot(this.direction);\r\n\t\t\tconst b1 = -diff.dot(segDir);\r\n\t\t\tconst c = diff.lengthSq();\r\n\t\t\tconst det = Math.abs(1.0 - a01 * a01);\r\n\r\n\t\t\tlet s0, s1, extDet, invDet, sqrDist;\r\n\r\n\t\t\tif(det > 0.0) {\r\n\r\n\t\t\t\t// The ray and segment are not parallel.\r\n\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\textDet = segExtent * det;\r\n\r\n\t\t\t\tif(s0 >= 0.0) {\r\n\r\n\t\t\t\t\tif(s1 >= -extDet) {\r\n\r\n\t\t\t\t\t\tif(s1 <= extDet) {\r\n\r\n\t\t\t\t\t\t\t// Region 0.\r\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\t\t\t\t\t\t\tinvDet = 1.0 / det;\r\n\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\tsqrDist = s0 * (s0 + a01 * s1 + 2.0 * b0) + s1 * (a01 * s0 + s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// Region 1.\r\n\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max(0.0, -(a01 * s1 + b0));\r\n\t\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// Region 5.\r\n\t\t\t\t\t\ts1 = -segExtent;\r\n\t\t\t\t\t\ts0 = Math.max(0.0, -(a01 * s1 + b0));\r\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif(s1 <= -extDet) {\r\n\r\n\t\t\t\t\t\t// Region 4.\r\n\t\t\t\t\t\ts0 = Math.max(0.0, -(-a01 * segExtent + b0));\r\n\t\t\t\t\t\ts1 = (s0 > 0.0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\r\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t} else if(s1 <= extDet) {\r\n\r\n\t\t\t\t\t\t// Region 3.\r\n\t\t\t\t\t\ts0 = 0.0;\r\n\t\t\t\t\t\ts1 = Math.min(Math.max(-segExtent, -b1), segExtent);\r\n\t\t\t\t\t\tsqrDist = s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// Region 2.\r\n\t\t\t\t\t\ts0 = Math.max(0.0, -(a01 * segExtent + b0));\r\n\t\t\t\t\t\ts1 = (s0 > 0.0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\r\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Ray and segment are parallel.\r\n\t\t\t\ts1 = (a01 > 0.0) ? -segExtent : segExtent;\r\n\t\t\t\ts0 = Math.max(0.0, -(a01 * s1 + b0));\r\n\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(pointOnRay !== undefined) {\r\n\r\n\t\t\t\tpointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(pointOnSegment !== undefined) {\r\n\r\n\t\t\t\tpointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn sqrDist;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds the point where this ray intersects the given sphere.\r\n\t\t *\r\n\t\t * @param {Sphere} s - A sphere.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The point of intersection, or null if there is none.\r\n\t\t */\r\n\r\n\t\tintersectSphere(s, target = new Vector3()) {\r\n\r\n\t\t\tconst ab = v$3[0].subVectors(s.center, this.origin);\r\n\t\t\tconst tca = ab.dot(this.direction);\r\n\t\t\tconst d2 = ab.dot(ab) - tca * tca;\r\n\t\t\tconst radius2 = s.radius * s.radius;\r\n\r\n\t\t\tlet result = null;\r\n\t\t\tlet thc, t0, t1;\r\n\r\n\t\t\tif(d2 <= radius2) {\r\n\r\n\t\t\t\tthc = Math.sqrt(radius2 - d2);\r\n\r\n\t\t\t\t// t0 = first intersection point - entrance on front of sphere.\r\n\t\t\t\tt0 = tca - thc;\r\n\r\n\t\t\t\t// t1 = second intersection point - exit point on back of sphere.\r\n\t\t\t\tt1 = tca + thc;\r\n\r\n\t\t\t\t// Check if both t0 and t1 are behind the ray - if so, return null.\r\n\t\t\t\tif(t0 >= 0.0 || t1 >= 0.0) {\r\n\r\n\t\t\t\t\t/* Check if t0 is behind the ray. If it is, the ray is inside the\r\n\t\t\t\t\tsphere, so return the second exit point scaled by t1 in order to always\r\n\t\t\t\t\treturn an intersection point that is in front of the ray. If t0 is in\r\n\t\t\t\t\tfront of the ray, return the first collision point scaled by t0. */\r\n\t\t\t\t\tresult = (t0 < 0.0) ? this.at(t1, target) : this.at(t0, target);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Determines whether this ray intersects the given sphere.\r\n\t\t *\r\n\t\t * @param {Sphere} s - A sphere.\r\n\t\t * @return {Boolean} Whether this ray intersects the given sphere.\r\n\t\t */\r\n\r\n\t\tintersectsSphere(s) {\r\n\r\n\t\t\treturn (this.distanceToPoint(s.center) <= s.radius);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds the point where this ray intersects the given plane.\r\n\t\t *\r\n\t\t * @param {Plane} p - A plane.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The point of intersection, or null if there is none.\r\n\t\t */\r\n\r\n\t\tintersectPlane(p, target = new Vector3()) {\r\n\r\n\t\t\tconst t = this.distanceToPlane(p);\r\n\r\n\t\t\treturn (t === null) ? null : this.at(t, target);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Determines whether this ray intersects the given plane.\r\n\t\t *\r\n\t\t * @param {Plane} p - A plane.\r\n\t\t * @return {Boolean} Whether this ray intersects the given plane.\r\n\t\t */\r\n\r\n\t\tintersectsPlane(p) {\r\n\r\n\t\t\tconst distanceToPoint = p.distanceToPoint(this.origin);\r\n\r\n\t\t\treturn (distanceToPoint === 0.0 || p.normal.dot(this.direction) * distanceToPoint < 0.0);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds the point where this ray intersects the given box.\r\n\t\t *\r\n\t\t * @param {Plane} b - A box.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The point of intersection, or null if there is none.\r\n\t\t */\r\n\r\n\t\tintersectBox(b, target = new Vector3()) {\r\n\r\n\t\t\tconst origin = this.origin;\r\n\t\t\tconst direction = this.direction;\r\n\t\t\tconst min = b.min;\r\n\t\t\tconst max = b.max;\r\n\r\n\t\t\tconst invDirX = 1.0 / direction.x;\r\n\t\t\tconst invDirY = 1.0 / direction.y;\r\n\t\t\tconst invDirZ = 1.0 / direction.z;\r\n\r\n\t\t\tlet result = null;\r\n\t\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n\t\t\tif(invDirX >= 0.0) {\r\n\r\n\t\t\t\ttmin = (min.x - origin.x) * invDirX;\r\n\t\t\t\ttmax = (max.x - origin.x) * invDirX;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttmin = (max.x - origin.x) * invDirX;\r\n\t\t\t\ttmax = (min.x - origin.x) * invDirX;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(invDirY >= 0.0) {\r\n\r\n\t\t\t\ttymin = (min.y - origin.y) * invDirY;\r\n\t\t\t\ttymax = (max.y - origin.y) * invDirY;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttymin = (max.y - origin.y) * invDirY;\r\n\t\t\t\ttymax = (min.y - origin.y) * invDirY;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(tmin <= tymax && tymin <= tmax) {\r\n\r\n\t\t\t\t/* Handle the case where tmin or tmax is NaN (result of 0 * Infinity).\r\n\t\t\t\tNote: x !== x returns true if x is NaN. */\r\n\t\t\t\tif(tymin > tmin || tmin !== tmin) { tmin = tymin; }\r\n\t\t\t\tif(tymax < tmax || tmax !== tmax) { tmax = tymax; }\r\n\r\n\t\t\t\tif(invDirZ >= 0.0) {\r\n\r\n\t\t\t\t\ttzmin = (min.z - origin.z) * invDirZ;\r\n\t\t\t\t\ttzmax = (max.z - origin.z) * invDirZ;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttzmin = (max.z - origin.z) * invDirZ;\r\n\t\t\t\t\ttzmax = (min.z - origin.z) * invDirZ;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(tmin <= tzmax && tzmin <= tmax) {\r\n\r\n\t\t\t\t\tif(tzmin > tmin || tmin !== tmin) { tmin = tzmin; }\r\n\t\t\t\t\tif(tzmax < tmax || tmax !== tmax) { tmax = tzmax; }\r\n\r\n\t\t\t\t\t// Return the closest point (positive side).\r\n\t\t\t\t\tif(tmax >= 0.0) {\r\n\r\n\t\t\t\t\t\tresult = this.at((tmin >= 0.0) ? tmin : tmax, target);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Determines whether this ray intersects the given box.\r\n\t\t *\r\n\t\t * @param {Box3} b - A box.\r\n\t\t * @return {Boolean} Whether this ray intersects the given box.\r\n\t\t */\r\n\r\n\t\tintersectsBox(b) {\r\n\r\n\t\t\treturn (this.intersectBox(b, v$3[0]) !== null);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds the point where this ray intersects the given triangle.\r\n\t\t *\r\n\t\t * Based on:\r\n\t\t *  http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\r\n\t\t *\r\n\t\t * @param {Vector3} a - A triangle vertex.\r\n\t\t * @param {Vector3} b - A triangle vertex.\r\n\t\t * @param {Vector3} c - A triangle vertex.\r\n\t\t * @param {Boolean} [backfaceCulling=false] - Whether backface culling should be considered.\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} The point of intersection, or null if there is none.\r\n\t\t */\r\n\r\n\t\tintersectTriangle(a, b, c, backfaceCulling, target) {\r\n\r\n\t\t\tconst direction = this.direction;\r\n\r\n\t\t\t// Compute the offset origin, edges, and normal.\r\n\t\t\tconst diff = v$3[0];\r\n\t\t\tconst edge1 = v$3[1];\r\n\t\t\tconst edge2 = v$3[2];\r\n\t\t\tconst normal = v$3[3];\r\n\r\n\t\t\tlet result = null;\r\n\t\t\tlet DdN, sign, DdQxE2, DdE1xQ, QdN;\r\n\r\n\t\t\tedge1.subVectors(b, a);\r\n\t\t\tedge2.subVectors(c, a);\r\n\t\t\tnormal.crossVectors(edge1, edge2);\r\n\r\n\t\t\t/* Solve Q + t * D = b1 * E1 + b2 * E2\r\n\t\t\t * (Q = kDiff, D = ray direction, E1 = kEdge1, E2 = kEdge2,\r\n\t\t\t * N = Cross(E1, E2)):\r\n\t\t\t *\r\n\t\t\t *   | Dot(D, N) | * b1 = sign(Dot(D, N)) * Dot(D, Cross(Q, E2))\r\n\t\t\t *   | Dot(D, N) | * b2 = sign(Dot(D, N)) * Dot(D, Cross(E1, Q))\r\n\t\t\t *   | Dot(D, N) | * t = -sign(Dot(D, N)) * Dot(Q, N)\r\n\t\t\t */\r\n\r\n\t\t\tDdN = direction.dot(normal);\r\n\r\n\t\t\t// Discard coplanar constellations and cull backfaces.\r\n\t\t\tif(DdN !== 0.0 && !(backfaceCulling && DdN > 0.0)) {\r\n\r\n\t\t\t\tif(DdN > 0.0) {\r\n\r\n\t\t\t\t\tsign = 1.0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsign = -1.0;\r\n\t\t\t\t\tDdN = -DdN;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdiff.subVectors(this.origin, a);\r\n\t\t\t\tDdQxE2 = sign * direction.dot(edge2.crossVectors(diff, edge2));\r\n\r\n\t\t\t\t// b1 < 0, no intersection.\r\n\t\t\t\tif(DdQxE2 >= 0.0) {\r\n\r\n\t\t\t\t\tDdE1xQ = sign * direction.dot(edge1.cross(diff));\r\n\r\n\t\t\t\t\t// b2 < 0, or b1 + b2 > 1, no intersection.\r\n\t\t\t\t\tif(DdE1xQ >= 0.0 && DdQxE2 + DdE1xQ <= DdN) {\r\n\r\n\t\t\t\t\t\t// The line intersects the triangle, check if the ray does.\r\n\t\t\t\t\t\tQdN = -sign * diff.dot(normal);\r\n\r\n\t\t\t\t\t\t// t < 0, no intersection.\r\n\t\t\t\t\t\tif(QdN >= 0.0) {\r\n\r\n\t\t\t\t\t\t\t// Ray intersects triangle.\r\n\t\t\t\t\t\t\tresult = this.at(QdN / DdN, target);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies the given matrix to this ray.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix.\r\n\t\t * @return {Ray} This ray.\r\n\t\t */\r\n\r\n\t\tapplyMatrix4(m) {\r\n\r\n\t\t\tthis.origin.applyMatrix4(m);\r\n\t\t\tthis.direction.transformDirection(m);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this ray equals the given one.\r\n\t\t *\r\n\t\t * @param {Ray} r - A ray.\r\n\t\t * @return {Boolean} Whether the rays are equal.\r\n\t\t */\r\n\r\n\t\tequals(r) {\r\n\r\n\t\t\treturn (r.origin.equals(this.origin) && r.direction.equals(this.direction));\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A spherical coordinate system.\r\n\t *\r\n\t * For details see: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n\t *\r\n\t * The poles (phi) are at the positive and negative Y-axis. The equator starts\r\n\t * at positive Z.\r\n\t */\n\n\t/**\r\n\t * A symmetric 3x3 matrix.\r\n\t */\r\n\r\n\tclass SymmetricMatrix3 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new symmetric matrix.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\t/**\r\n\t\t\t * The matrix elements.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.elements = new Float32Array([\r\n\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t1, 0,\r\n\t\t\t\t1\r\n\r\n\t\t\t]);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this matrix.\r\n\t\t *\r\n\t\t * @param {Number} m00 - The value of the first row, first column.\r\n\t\t * @param {Number} m01 - The value of the first row, second column and the second row, first column.\r\n\t\t * @param {Number} m02 - The value of the first row, third column and the third row, first column.\r\n\t\t * @param {Number} m11 - The value of the second row, second column.\r\n\t\t * @param {Number} m12 - The value of the second row, third column and third row, second column.\r\n\t\t * @param {Number} m22 - The value of the third row, third column.\r\n\t\t * @return {SymmetricMatrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tset(m00, m01, m02, m11, m12, m22) {\r\n\r\n\t\t\tconst e = this.elements;\r\n\r\n\t\t\te[0] = m00;\r\n\t\t\te[1] = m01; e[3] = m11;\r\n\t\t\te[2] = m02; e[4] = m12; e[5] = m22;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this matrix to the identity matrix.\r\n\t\t *\r\n\t\t * @return {SymmetricMatrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tidentity() {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t1, 0,\r\n\t\t\t\t1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of a given symmetric matrix.\r\n\t\t *\r\n\t\t * @param {SymmetricMatrix3} m - A matrix.\r\n\t\t * @return {SymmetricMatrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tcopy(m) {\r\n\r\n\t\t\tconst me = m.elements;\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\tme[0], me[1], me[2],\r\n\t\t\t\tme[3], me[4],\r\n\t\t\t\tme[5]\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this matrix.\r\n\t\t *\r\n\t\t * @return {SymmetricMatrix3} A clone of this matrix.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().copy(this);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies this symmetric matrix into a given 3x3 matrix.\r\n\t\t *\r\n\t\t * @param {Matrix3} m - The target matrix.\r\n\t\t */\r\n\r\n\t\ttoMatrix3(m) {\r\n\r\n\t\t\tconst me = m.elements;\r\n\r\n\t\t\tm.set(\r\n\r\n\t\t\t\tme[0], me[1], me[2],\r\n\t\t\t\tme[1], me[3], me[4],\r\n\t\t\t\tme[2], me[4], me[5]\r\n\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds the values of a given symmetric matrix to this one.\r\n\t\t *\r\n\t\t * @param {SymmetricMatrix3} m - A matrix.\r\n\t\t * @return {SymmetricMatrix3} This matrix.\r\n\t\t */\r\n\r\n\t\tadd(m) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst me = m.elements;\r\n\r\n\t\t\tte[0] += me[0];\r\n\t\t\tte[1] += me[1]; te[3] += me[3];\r\n\t\t\tte[2] += me[2]; te[4] += me[4]; te[5] += me[5];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Frobenius norm of this matrix.\r\n\t\t *\r\n\t\t * @return {Number} The norm of this matrix.\r\n\t\t */\r\n\r\n\t\tnorm() {\r\n\r\n\t\t\tconst e = this.elements;\r\n\r\n\t\t\tconst m01m01 = e[1] * e[1];\r\n\t\t\tconst m02m02 = e[2] * e[2];\r\n\t\t\tconst m12m12 = e[4] * e[4];\r\n\r\n\t\t\treturn Math.sqrt(\r\n\r\n\t\t\t\te[0] * e[0] + m01m01 + m02m02 +\r\n\t\t\t\tm01m01 + e[3] * e[3] + m12m12 +\r\n\t\t\t\tm02m02 + m12m12 + e[5] * e[5]\r\n\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the absolute sum of all matrix components except for the main\r\n\t\t * diagonal.\r\n\t\t *\r\n\t\t * @return {Number} The offset of this matrix.\r\n\t\t */\r\n\r\n\t\toff() {\r\n\r\n\t\t\tconst e = this.elements;\r\n\r\n\t\t\treturn Math.sqrt(2 * (\r\n\r\n\t\t\t\t// Diagonal = [0, 3, 5].\r\n\t\t\t\te[1] * e[1] + e[2] * e[2] + e[4] * e[4]\r\n\r\n\t\t\t));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies this symmetric matrix to a vector.\r\n\t\t *\r\n\t\t * @param {Vector3} v - The vector to modify.\r\n\t\t * @return {Vector3} The modified vector.\r\n\t\t */\r\n\r\n\t\tapplyToVector3(v) {\r\n\r\n\t\t\tconst x = v.x, y = v.y, z = v.z;\r\n\t\t\tconst e = this.elements;\r\n\r\n\t\t\tv.x = e[0] * x + e[1] * y + e[2] * z;\r\n\t\t\tv.y = e[1] * x + e[3] * y + e[4] * z;\r\n\t\t\tv.z = e[2] * x + e[4] * y + e[5] * z;\r\n\r\n\t\t\treturn v;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this matrix equals the given one.\r\n\t\t *\r\n\t\t * @param {SymmetricMatrix3} m - A matrix.\r\n\t\t * @return {Boolean} Whether the matrices are equal.\r\n\t\t */\r\n\r\n\t\tequals(matrix) {\r\n\r\n\t\t\tconst te = this.elements;\r\n\t\t\tconst me = matrix.elements;\r\n\r\n\t\t\tlet result = true;\r\n\t\t\tlet i;\r\n\r\n\t\t\tfor(i = 0; result && i < 6; ++i) {\r\n\r\n\t\t\t\tif(te[i] !== me[i]) {\r\n\r\n\t\t\t\t\tresult = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the linear index of an element from this matrix.\r\n\t\t *\r\n\t\t * Let N be the dimension of the symmetric matrix:\r\n\t\t *\r\n\t\t *     index = N * (N - 1) / 2 - (N - i) * (N - i - 1) / 2 + j\r\n\t\t *\r\n\t\t * @param {Number} i - The row.\r\n\t\t * @param {Number} j - The column.\r\n\t\t * @return {Number} The index into the elements of this matrix.\r\n\t\t */\r\n\r\n\t\tstatic calculateIndex(i, j) {\r\n\r\n\t\t\treturn (3 - (3 - i) * (2 - i) / 2 + j);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A vector with four components.\r\n\t */\r\n\r\n\tclass Vector4 {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new vector.\r\n\t\t *\r\n\t\t * @param {Number} [x=0] - The X component.\r\n\t\t * @param {Number} [y=0] - The Y component.\r\n\t\t * @param {Number} [z=0] - The Z component.\r\n\t\t * @param {Number} [w=0] - The W component.\r\n\t\t */\r\n\r\n\t\tconstructor(x = 0, y = 0, z = 0, w = 0) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The X component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.x = x;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Y component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.y = y;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Z component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.z = z;\r\n\r\n\t\t\t/**\r\n\t\t\t * The W component.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.w = w;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this vector\r\n\t\t *\r\n\t\t * @param {Number} x - The X component.\r\n\t\t * @param {Number} y - The Y component.\r\n\t\t * @param {Number} z - The Z component.\r\n\t\t * @param {Number} w - The W component.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tset(x, y, z, w) {\r\n\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\t\tthis.w = w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies the values of another vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tcopy(v) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\t\tthis.w = v.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this vector.\r\n\t\t *\r\n\t\t * @return {Vector4} A clone of this vector.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor(this.x, this.y, this.z, this.w);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies values from an array.\r\n\t\t *\r\n\t\t * @param {Number[]} array - An array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tfromArray(array, offset = 0) {\r\n\r\n\t\t\tthis.x = array[offset];\r\n\t\t\tthis.y = array[offset + 1];\r\n\t\t\tthis.z = array[offset + 2];\r\n\t\t\tthis.w = array[offset + 3];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores this vector in an array.\r\n\t\t *\r\n\t\t * @param {Array} [array] - A target array.\r\n\t\t * @param {Number} offset - An offset.\r\n\t\t * @return {Number[]} The array.\r\n\t\t */\r\n\r\n\t\ttoArray(array = [], offset = 0) {\r\n\r\n\t\t\tarray[offset] = this.x;\r\n\t\t\tarray[offset + 1] = this.y;\r\n\t\t\tarray[offset + 2] = this.z;\r\n\t\t\tarray[offset + 3] = this.w;\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores the axis angle from the given quaternion in this vector.\r\n\t\t *\r\n\t\t * For more details see:\r\n\t\t *  http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\t\t *\r\n\t\t * @param {Quaternion} q - A quaternion. Assumed to be normalized\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tsetAxisAngleFromQuaternion(q) {\r\n\r\n\t\t\tthis.w = 2 * Math.acos(q.w);\r\n\r\n\t\t\tconst s = Math.sqrt(1 - q.w * q.w);\r\n\r\n\t\t\tif(s < 1e-4) {\r\n\r\n\t\t\t\tthis.x = 1;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = q.x / s;\r\n\t\t\t\tthis.y = q.y / s;\r\n\t\t\t\tthis.z = q.z / s;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Stores the axis angle from the given rotation matrix in this vector.\r\n\t\t *\r\n\t\t * For more details see:\r\n\t\t *  http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix. The upper 3x3 must be a pure rotation matrix (i.e. unscaled).\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tsetAxisAngleFromRotationMatrix(m) {\r\n\r\n\t\t\t// Margin to allow for rounding errors.\r\n\t\t\tconst E = 0.01;\r\n\t\t\t// Margin to distinguish between 0 and 180 degrees.\r\n\t\t\tconst H = 0.1;\r\n\r\n\t\t\tconst me = m.elements;\r\n\t\t\tconst m00 = me[0], m01 = me[4], m02 = me[8];\r\n\t\t\tconst m10 = me[1], m11 = me[5], m12 = me[9];\r\n\t\t\tconst m20 = me[2], m21 = me[6], m22 = me[10];\r\n\r\n\t\t\tlet angle;\r\n\t\t\tlet x, y, z;\r\n\t\t\tlet xx, yy, zz;\r\n\t\t\tlet xy, xz, yz;\r\n\t\t\tlet s;\r\n\r\n\t\t\tif((Math.abs(m01 - m10) < E) && (Math.abs(m02 - m20) < E) && (Math.abs(m12 - m21) < E)) {\r\n\r\n\t\t\t\t/* Singularity found. First, check for identity matrix which must have +1\r\n\t\t\t\tfor all terms in the leading diagonal and zero in other terms. */\r\n\t\t\t\tif((Math.abs(m01 + m10) < H) && (Math.abs(m02 + m20) < H) && (Math.abs(m12 + m21) < H) && (Math.abs(m00 + m11 + m22 - 3) < H)) {\r\n\r\n\t\t\t\t\t// This singularity is the identity matrix. The angle is zero.\r\n\t\t\t\t\tthis.set(1, 0, 0, 0);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// The angle is 180.\r\n\t\t\t\t\tangle = Math.PI;\r\n\r\n\t\t\t\t\txx = (m00 + 1) / 2;\r\n\t\t\t\t\tyy = (m11 + 1) / 2;\r\n\t\t\t\t\tzz = (m22 + 1) / 2;\r\n\t\t\t\t\txy = (m01 + m10) / 4;\r\n\t\t\t\t\txz = (m02 + m20) / 4;\r\n\t\t\t\t\tyz = (m12 + m21) / 4;\r\n\r\n\t\t\t\t\tif((xx > yy) && (xx > zz)) {\r\n\r\n\t\t\t\t\t\t// m00 is the largest diagonal term.\r\n\t\t\t\t\t\tif(xx < E) {\r\n\r\n\t\t\t\t\t\t\tx = 0;\r\n\t\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tx = Math.sqrt(xx);\r\n\t\t\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if(yy > zz) {\r\n\r\n\t\t\t\t\t\t// m11 is the largest diagonal term.\r\n\t\t\t\t\t\tif(yy < E) {\r\n\r\n\t\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\t\ty = 0;\r\n\t\t\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ty = Math.sqrt(yy);\r\n\t\t\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// m22 is the largest diagonal term.\r\n\t\t\t\t\t\tif(zz < E) {\r\n\r\n\t\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tz = Math.sqrt(zz);\r\n\t\t\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.set(x, y, z, angle);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// There are no singularities.\r\n\t\t\t\ts = Math.sqrt(\r\n\t\t\t\t\t(m21 - m12) * (m21 - m12) +\r\n\t\t\t\t\t(m02 - m20) * (m02 - m20) +\r\n\t\t\t\t\t(m10 - m01) * (m10 - m01)\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Prevent division by zero.\r\n\t\t\t\tif(Math.abs(s) < 0.001) { s = 1; }\r\n\r\n\t\t\t\tthis.x = (m21 - m12) / s;\r\n\t\t\t\tthis.y = (m02 - m20) / s;\r\n\t\t\t\tthis.z = (m10 - m01) / s;\r\n\t\t\t\tthis.w = Math.acos((m00 + m11 + m22 - 1) / 2);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a vector to this one.\r\n\t\t *\r\n\t\t * @param {Vector4} v - The vector to add.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tadd(v) {\r\n\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\t\tthis.w += v.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a scalar to this vector.\r\n\t\t *\r\n\t\t * @param {Number} s - The scalar to add.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\taddScalar(s) {\r\n\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\t\tthis.w += s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the sum of two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector4} a - A vector.\r\n\t\t * @param {Vector4} b - Another vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\taddVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\t\tthis.w = a.w + b.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a scaled vector to this one.\r\n\t\t *\r\n\t\t * @param {Vector4} v - The vector to scale and add.\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\taddScaledVector(v, s) {\r\n\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\t\tthis.z += v.z * s;\r\n\t\t\tthis.w += v.w * s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts a vector from this vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - The vector to subtract.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tsub(v) {\r\n\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\t\tthis.w -= v.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts a scalar from this vector.\r\n\t\t *\r\n\t\t * @param {Number} s - The scalar to subtract.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tsubScalar(s) {\r\n\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\t\tthis.w -= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the difference between two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector4} a - A vector.\r\n\t\t * @param {Vector4} b - A second vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tsubVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\t\tthis.w = a.w - b.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this vector with another vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tmultiply(v) {\r\n\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\t\tthis.z *= v.z;\r\n\t\t\tthis.w *= v.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Multiplies this vector with a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tmultiplyScalar(s) {\r\n\r\n\t\t\tthis.x *= s;\r\n\t\t\tthis.y *= s;\r\n\t\t\tthis.z *= s;\r\n\t\t\tthis.w *= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the product of two given vectors.\r\n\t\t *\r\n\t\t * @param {Vector4} a - A vector.\r\n\t\t * @param {Vector4} b - Another vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tmultiplyVectors(a, b) {\r\n\r\n\t\t\tthis.x = a.x * b.x;\r\n\t\t\tthis.y = a.y * b.y;\r\n\t\t\tthis.z = a.z * b.z;\r\n\t\t\tthis.w = a.w * b.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Divides this vector by another vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tdivide(v) {\r\n\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\t\tthis.z /= v.z;\r\n\t\t\tthis.w /= v.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Divides this vector by a given scalar.\r\n\t\t *\r\n\t\t * @param {Number} s - A scalar.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tdivideScalar(s) {\r\n\r\n\t\t\tthis.x /= s;\r\n\t\t\tthis.y /= s;\r\n\t\t\tthis.z /= s;\r\n\t\t\tthis.w /= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Applies a matrix to this vector.\r\n\t\t *\r\n\t\t * @param {Matrix4} m - A matrix.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tapplyMatrix4(m) {\r\n\r\n\t\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\r\n\t\t\tconst e = m.elements;\r\n\r\n\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\r\n\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\r\n\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\r\n\t\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Negates this vector.\r\n\t\t *\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tnegate() {\r\n\r\n\t\t\tthis.x = -this.x;\r\n\t\t\tthis.y = -this.y;\r\n\t\t\tthis.z = -this.z;\r\n\t\t\tthis.w = -this.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the dot product with another vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Number} The dot product.\r\n\t\t */\r\n\r\n\t\tdot(v) {\r\n\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Manhattan length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tmanhattanLength() {\r\n\r\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The squared length.\r\n\t\t */\r\n\r\n\t\tlengthSquared() {\r\n\r\n\t\t\treturn (\r\n\t\t\t\tthis.x * this.x +\r\n\t\t\t\tthis.y * this.y +\r\n\t\t\t\tthis.z * this.z +\r\n\t\t\t\tthis.w * this.w\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the length of this vector.\r\n\t\t *\r\n\t\t * @return {Number} The length.\r\n\t\t */\r\n\r\n\t\tlength() {\r\n\r\n\t\t\treturn Math.sqrt(\r\n\t\t\t\tthis.x * this.x +\r\n\t\t\t\tthis.y * this.y +\r\n\t\t\t\tthis.z * this.z +\r\n\t\t\t\tthis.w * this.w\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Manhattan distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tmanhattanDistanceTo(v) {\r\n\r\n\t\t\treturn (\r\n\t\t\t\tMath.abs(this.x - v.x) +\r\n\t\t\t\tMath.abs(this.y - v.y) +\r\n\t\t\t\tMath.abs(this.z - v.z) +\r\n\t\t\t\tMath.abs(this.w - v.w)\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the squared distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Number} The squared distance.\r\n\t\t */\r\n\r\n\t\tdistanceToSquared(v) {\r\n\r\n\t\t\tconst dx = this.x - v.x;\r\n\t\t\tconst dy = this.y - v.y;\r\n\t\t\tconst dz = this.z - v.z;\r\n\t\t\tconst dw = this.w - v.w;\r\n\r\n\t\t\treturn dx * dx + dy * dy + dz * dz + dw * dw;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the distance to a given vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Number} The distance.\r\n\t\t */\r\n\r\n\t\tdistanceTo(v) {\r\n\r\n\t\t\treturn Math.sqrt(this.distanceToSquared(v));\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Normalizes this vector.\r\n\t\t *\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tnormalize() {\r\n\r\n\t\t\treturn this.divideScalar(this.length());\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the length of this vector.\r\n\t\t *\r\n\t\t * @param {Number} length - The new length.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tsetLength(length) {\r\n\r\n\t\t\treturn this.normalize().multiplyScalar(length);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the min value for each component of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tmin(v) {\r\n\r\n\t\t\tthis.x = Math.min(this.x, v.x);\r\n\t\t\tthis.y = Math.min(this.y, v.y);\r\n\t\t\tthis.z = Math.min(this.z, v.z);\r\n\t\t\tthis.w = Math.min(this.w, v.w);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the max value for each component of this vector and the given one.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tmax(v) {\r\n\r\n\t\t\tthis.x = Math.max(this.x, v.x);\r\n\t\t\tthis.y = Math.max(this.y, v.y);\r\n\t\t\tthis.z = Math.max(this.z, v.z);\r\n\t\t\tthis.w = Math.max(this.w, v.w);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clamps this vector.\r\n\t\t *\r\n\t\t * @param {Vector4} min - The lower bounds. Assumed to be smaller than max.\r\n\t\t * @param {Vector4} max - The upper bounds. Assumed to be greater than min.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tclamp(min, max) {\r\n\r\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\r\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\r\n\t\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\r\n\t\t\tthis.w = Math.max(min.w, Math.min(max.w, this.w));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Floors this vector.\r\n\t\t *\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tfloor() {\r\n\r\n\t\t\tthis.x = Math.floor(this.x);\r\n\t\t\tthis.y = Math.floor(this.y);\r\n\t\t\tthis.z = Math.floor(this.z);\r\n\t\t\tthis.w = Math.floor(this.w);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Ceils this vector.\r\n\t\t *\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tceil() {\r\n\r\n\t\t\tthis.x = Math.ceil(this.x);\r\n\t\t\tthis.y = Math.ceil(this.y);\r\n\t\t\tthis.z = Math.ceil(this.z);\r\n\t\t\tthis.w = Math.ceil(this.w);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rounds this vector.\r\n\t\t *\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tround() {\r\n\r\n\t\t\tthis.x = Math.round(this.x);\r\n\t\t\tthis.y = Math.round(this.y);\r\n\t\t\tthis.z = Math.round(this.z);\r\n\t\t\tthis.w = Math.round(this.w);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Lerps towards the given vector.\r\n\t\t *\r\n\t\t * @param {Vector4} v - The target vector.\r\n\t\t * @param {Number} alpha - The lerp factor.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tlerp(v, alpha) {\r\n\r\n\t\t\tthis.x += (v.x - this.x) * alpha;\r\n\t\t\tthis.y += (v.y - this.y) * alpha;\r\n\t\t\tthis.z += (v.z - this.z) * alpha;\r\n\t\t\tthis.w += (v.w - this.w) * alpha;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets this vector to the lerp result of the given vectors.\r\n\t\t *\r\n\t\t * @param {Vector4} v1 - A base vector.\r\n\t\t * @param {Vector4} v2 - The target vector.\r\n\t\t * @param {Number} alpha - The lerp factor.\r\n\t\t * @return {Vector4} This vector.\r\n\t\t */\r\n\r\n\t\tlerpVectors(v1, v2, alpha) {\r\n\r\n\t\t\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if this vector equals the given one.\r\n\t\t *\r\n\t\t * @param {Vector4} v - A vector.\r\n\t\t * @return {Boolean} Whether this vector equals the given one.\r\n\t\t */\r\n\r\n\t\tequals(v) {\r\n\r\n\t\t\treturn (v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Mathematical data structures.\r\n\t *\r\n\t * @module math-ds\r\n\t */\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst c$2 = new Vector3();\r\n\r\n\t/**\r\n\t * An octant.\r\n\t */\r\n\r\n\tclass Octant {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new octant.\r\n\t\t *\r\n\t\t * @param {Vector3} [min] - The lower bounds.\r\n\t\t * @param {Vector3} [max] - The upper bounds.\r\n\t\t */\r\n\r\n\t\tconstructor(min = new Vector3(), max = new Vector3()) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The lower bounds of this octant.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.min = min;\r\n\r\n\t\t\t/**\r\n\t\t\t * The upper bounds of the octant.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.max = max;\r\n\r\n\t\t\t/**\r\n\t\t\t * The children of this octant.\r\n\t\t\t *\r\n\t\t\t * @type {Octant[]}\r\n\t\t\t * @default null\r\n\t\t\t */\r\n\r\n\t\t\tthis.children = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the center of this octant.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the center of this octant.\r\n\t\t */\r\n\r\n\t\tgetCenter(target = new Vector3()) {\r\n\r\n\t\t\treturn target.addVectors(this.min, this.max).multiplyScalar(0.5);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the size of this octant.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the size of this octant.\r\n\t\t */\r\n\r\n\t\tgetDimensions(target = new Vector3()) {\r\n\r\n\t\t\treturn target.subVectors(this.max, this.min);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Splits this octant into eight smaller ones.\r\n\t\t */\r\n\r\n\t\tsplit() {\r\n\r\n\t\t\tconst min = this.min;\r\n\t\t\tconst max = this.max;\r\n\t\t\tconst mid = this.getCenter(c$2);\r\n\r\n\t\t\tconst children = this.children = [\r\n\r\n\t\t\t\tnull, null,\r\n\t\t\t\tnull, null,\r\n\t\t\t\tnull, null,\r\n\t\t\t\tnull, null\r\n\r\n\t\t\t];\r\n\r\n\t\t\tlet i, combination;\r\n\r\n\t\t\tfor(i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\tcombination = pattern[i];\r\n\r\n\t\t\t\tchildren[i] = new this.constructor(\r\n\r\n\t\t\t\t\tnew Vector3(\r\n\t\t\t\t\t\t(combination[0] === 0) ? min.x : mid.x,\r\n\t\t\t\t\t\t(combination[1] === 0) ? min.y : mid.y,\r\n\t\t\t\t\t\t(combination[2] === 0) ? min.z : mid.z\r\n\t\t\t\t\t),\r\n\r\n\t\t\t\t\tnew Vector3(\r\n\t\t\t\t\t\t(combination[0] === 0) ? mid.x : max.x,\r\n\t\t\t\t\t\t(combination[1] === 0) ? mid.y : max.y,\r\n\t\t\t\t\t\t(combination[2] === 0) ? mid.z : max.z\r\n\t\t\t\t\t)\r\n\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A binary pattern that describes the standard octant layout:\r\n\t *\r\n\t * ```text\r\n\t *    3____7\r\n\t *  2/___6/|\r\n\t *  | 1__|_5\r\n\t *  0/___4/\r\n\t * ```\r\n\t *\r\n\t * This common layout is crucial for positional assumptions.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t */\r\n\r\n\tconst pattern = [\r\n\r\n\t\tnew Uint8Array([0, 0, 0]),\r\n\t\tnew Uint8Array([0, 0, 1]),\r\n\t\tnew Uint8Array([0, 1, 0]),\r\n\t\tnew Uint8Array([0, 1, 1]),\r\n\r\n\t\tnew Uint8Array([1, 0, 0]),\r\n\t\tnew Uint8Array([1, 0, 1]),\r\n\t\tnew Uint8Array([1, 1, 0]),\r\n\t\tnew Uint8Array([1, 1, 1])\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * Describes all possible octant corner connections.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t */\r\n\r\n\tconst edges = [\r\n\r\n\t\t// X-Axis.\r\n\t\tnew Uint8Array([0, 4]),\r\n\t\tnew Uint8Array([1, 5]),\r\n\t\tnew Uint8Array([2, 6]),\r\n\t\tnew Uint8Array([3, 7]),\r\n\r\n\t\t// Y-Axis.\r\n\t\tnew Uint8Array([0, 2]),\r\n\t\tnew Uint8Array([1, 3]),\r\n\t\tnew Uint8Array([4, 6]),\r\n\t\tnew Uint8Array([5, 7]),\r\n\r\n\t\t// Z-Axis.\r\n\t\tnew Uint8Array([0, 1]),\r\n\t\tnew Uint8Array([2, 3]),\r\n\t\tnew Uint8Array([4, 5]),\r\n\t\tnew Uint8Array([6, 7])\r\n\r\n\t];\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst c = new Vector3();\r\n\r\n\t/**\r\n\t * A cubic octant.\r\n\t */\r\n\r\n\tclass CubicOctant {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new cubic octant.\r\n\t\t *\r\n\t\t * @param {Vector3} [min] - The lower bounds.\r\n\t\t * @param {Number} [size=0] - The size of the octant.\r\n\t\t */\r\n\r\n\t\tconstructor(min = new Vector3(), size = 0) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The lower bounds of this octant.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.min = min;\r\n\r\n\t\t\t/**\r\n\t\t\t * The size of this octant.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.size = size;\r\n\r\n\t\t\t/**\r\n\t\t\t * The children of this octant.\r\n\t\t\t *\r\n\t\t\t * @type {CubicOctant[]}\r\n\t\t\t * @default null\r\n\t\t\t */\r\n\r\n\t\t\tthis.children = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The upper bounds of this octant.\r\n\t\t *\r\n\t\t * Accessing this property always creates a new vector.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tget max() { return this.min.clone().addScalar(this.size); }\r\n\r\n\t\t/**\r\n\t\t * Computes the center of this octant.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the center of this octant.\r\n\t\t */\r\n\r\n\t\tgetCenter(target = new Vector3()) {\r\n\r\n\t\t\treturn target.copy(this.min).addScalar(this.size * 0.5);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the size of this octant as a vector.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the size of this octant.\r\n\t\t */\r\n\r\n\t\tgetDimensions(target = new Vector3()) {\r\n\r\n\t\t\treturn target.set(this.size, this.size, this.size);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Splits this octant into eight smaller ones.\r\n\t\t */\r\n\r\n\t\tsplit() {\r\n\r\n\t\t\tconst min = this.min;\r\n\t\t\tconst mid = this.getCenter(c);\r\n\t\t\tconst halfSize = this.size * 0.5;\r\n\r\n\t\t\tconst children = this.children = [\r\n\r\n\t\t\t\tnull, null,\r\n\t\t\t\tnull, null,\r\n\t\t\t\tnull, null,\r\n\t\t\t\tnull, null\r\n\r\n\t\t\t];\r\n\r\n\t\t\tlet i, combination;\r\n\r\n\t\t\tfor(i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\tcombination = pattern[i];\r\n\r\n\t\t\t\tchildren[i] = new this.constructor(\r\n\r\n\t\t\t\t\tnew Vector3(\r\n\t\t\t\t\t\t(combination[0] === 0) ? min.x : mid.x,\r\n\t\t\t\t\t\t(combination[1] === 0) ? min.y : mid.y,\r\n\t\t\t\t\t\t(combination[2] === 0) ? min.z : mid.z\r\n\t\t\t\t\t),\r\n\r\n\t\t\t\t\thalfSize\r\n\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A basic iterator result.\r\n\t *\r\n\t * The next method of an iterator always has to return an object with\r\n\t * appropriate properties including done and value.\r\n\t */\r\n\r\n\tclass IteratorResult {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new iterator result.\r\n\t\t *\r\n\t\t * @param {Vector3} [value=null] - A value.\r\n\t\t * @param {Vector3} [done=false] - Whether this result is past the end of the iterated sequence.\r\n\t\t */\r\n\r\n\t\tconstructor(value = null, done = false) {\r\n\r\n\t\t\t/**\r\n\t\t\t * An arbitrary value returned by the iterator.\r\n\t\t\t *\r\n\t\t\t * @type Object\r\n\t\t\t * @default null\r\n\t\t\t */\r\n\r\n\t\t\tthis.value = value;\r\n\r\n\t\t\t/**\r\n\t\t\t * Whether this result is past the end of the iterated sequence.\r\n\t\t\t *\r\n\t\t\t * @type Boolean\r\n\t\t\t * @default false\r\n\t\t\t */\r\n\r\n\t\t\tthis.done = done;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Resets this iterator result.\r\n\t\t */\r\n\r\n\t\treset() {\r\n\r\n\t\t\tthis.value = null;\r\n\t\t\tthis.done = false;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A compilation of the library components.\r\n\t *\r\n\t * @module iterator-result\r\n\t */\n\n\t/**\r\n\t * A 3D box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b$4 = new Box3();\r\n\r\n\t/**\r\n\t * An octant iterator.\r\n\t *\r\n\t * @implements {Iterator}\r\n\t * @implements {Iterable}\r\n\t */\r\n\r\n\tclass OctantIterator {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new octant iterator.\r\n\t\t *\r\n\t\t * @param {Octree} octree - An octree.\r\n\t\t * @param {Frustum|Box3} [region=null] - A cull region.\r\n\t\t */\r\n\r\n\t\tconstructor(octree, region = null) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The octree.\r\n\t\t\t *\r\n\t\t\t * @type {Octree}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.octree = octree;\r\n\r\n\t\t\t/**\r\n\t\t\t * A region used for octree culling.\r\n\t\t\t *\r\n\t\t\t * @type {Frustum|Box3}\r\n\t\t\t * @default null\r\n\t\t\t */\r\n\r\n\t\t\tthis.region = region;\r\n\r\n\t\t\t/**\r\n\t\t\t * Whether this iterator should respect the cull region.\r\n\t\t\t *\r\n\t\t\t * @type {Boolean}\r\n\t\t\t * @default false\r\n\t\t\t */\r\n\r\n\t\t\tthis.cull = (region !== null);\r\n\r\n\t\t\t/**\r\n\t\t\t * An iterator result.\r\n\t\t\t *\r\n\t\t\t * @type {IteratorResult}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.result = new IteratorResult();\r\n\r\n\t\t\t/**\r\n\t\t\t * An octant trace.\r\n\t\t\t *\r\n\t\t\t * @type {Octant[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.trace = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * Iteration indices.\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.indices = null;\r\n\r\n\t\t\tthis.reset();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Resets this iterator.\r\n\t\t *\r\n\t\t * @return {OctantIterator} This iterator.\r\n\t\t */\r\n\r\n\t\treset() {\r\n\r\n\t\t\tconst root = this.octree.root;\r\n\r\n\t\t\tthis.trace = [];\r\n\t\t\tthis.indices = [];\r\n\r\n\t\t\tif(root !== null) {\r\n\r\n\t\t\t\tb$4.min = root.min;\r\n\t\t\t\tb$4.max = root.max;\r\n\r\n\t\t\t\tif(!this.cull || this.region.intersectsBox(b$4)) {\r\n\r\n\t\t\t\t\tthis.trace.push(root);\r\n\t\t\t\t\tthis.indices.push(0);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.result.reset();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Iterates over the leaf octants.\r\n\t\t *\r\n\t\t * @return {IteratorResult} The next leaf octant.\r\n\t\t */\r\n\r\n\t\tnext() {\r\n\r\n\t\t\tconst cull = this.cull;\r\n\t\t\tconst region = this.region;\r\n\t\t\tconst indices = this.indices;\r\n\t\t\tconst trace = this.trace;\r\n\r\n\t\t\tlet octant = null;\r\n\t\t\tlet depth = trace.length - 1;\r\n\r\n\t\t\tlet index, children, child;\r\n\r\n\t\t\twhile(octant === null && depth >= 0) {\r\n\r\n\t\t\t\tindex = indices[depth];\r\n\t\t\t\tchildren = trace[depth].children;\r\n\r\n\t\t\t\t++indices[depth];\r\n\r\n\t\t\t\tif(index < 8) {\r\n\r\n\t\t\t\t\tif(children !== null) {\r\n\r\n\t\t\t\t\t\tchild = children[index];\r\n\r\n\t\t\t\t\t\tif(cull) {\r\n\r\n\t\t\t\t\t\t\tb$4.min = child.min;\r\n\t\t\t\t\t\t\tb$4.max = child.max;\r\n\r\n\t\t\t\t\t\t\tif(!region.intersectsBox(b$4)) {\r\n\r\n\t\t\t\t\t\t\t\t// Cull this octant.\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttrace.push(child);\r\n\t\t\t\t\t\tindices.push(0);\r\n\r\n\t\t\t\t\t\t++depth;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\toctant = trace.pop();\r\n\t\t\t\t\t\tindices.pop();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttrace.pop();\r\n\t\t\t\t\tindices.pop();\r\n\r\n\t\t\t\t\t--depth;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.result.value = octant;\r\n\t\t\tthis.result.done = (octant === null);\r\n\r\n\t\t\treturn this.result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Called when this iterator will no longer be run to completion.\r\n\t\t *\r\n\t\t * @param {Object} value - An interator result value.\r\n\t\t * @return {IteratorResult} - A premature completion result.\r\n\t\t */\r\n\r\n\t\treturn(value) {\r\n\r\n\t\t\tthis.result.value = value;\r\n\t\t\tthis.result.done = true;\r\n\r\n\t\t\treturn this.result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns this iterator.\r\n\t\t *\r\n\t\t * @return {OctantIterator} An iterator.\r\n\t\t */\r\n\r\n\t\t[Symbol.iterator]() {\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A list of vectors.\r\n\t *\r\n\t * @type {Vector3[]}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst v$4 = [\r\n\t\tnew Vector3(),\r\n\t\tnew Vector3(),\r\n\t\tnew Vector3()\r\n\t];\r\n\r\n\t/**\r\n\t * A box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst b$5 = new Box3();\r\n\r\n\t/**\r\n\t * A ray.\r\n\t *\r\n\t * @type {Ray}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst r = new Ray();\r\n\r\n\t/**\r\n\t * A lookup-table containing octant ids. Used to determine the exit plane from\r\n\t * an octant.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst octantTable = [\r\n\r\n\t\tnew Uint8Array([4, 2, 1]),\r\n\t\tnew Uint8Array([5, 3, 8]),\r\n\t\tnew Uint8Array([6, 8, 3]),\r\n\t\tnew Uint8Array([7, 8, 8]),\r\n\t\tnew Uint8Array([8, 6, 5]),\r\n\t\tnew Uint8Array([8, 7, 8]),\r\n\t\tnew Uint8Array([8, 8, 7]),\r\n\t\tnew Uint8Array([8, 8, 8])\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * A byte that stores raycasting flags.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tlet flags = 0;\r\n\r\n\t/**\r\n\t * Finds the entry plane of the first octant that a ray travels through.\r\n\t *\r\n\t * Determining the first octant requires knowing which of the t0s is the\r\n\t * largest. The tms of the other axes must also be compared against that\r\n\t * largest t0.\r\n\t *\r\n\t * @private\r\n\t * @param {Number} tx0 - Ray projection parameter.\r\n\t * @param {Number} ty0 - Ray projection parameter.\r\n\t * @param {Number} tz0 - Ray projection parameter.\r\n\t * @param {Number} txm - Ray projection parameter mean.\r\n\t * @param {Number} tym - Ray projection parameter mean.\r\n\t * @param {Number} tzm - Ray projection parameter mean.\r\n\t * @return {Number} The index of the first octant that the ray travels through.\r\n\t */\r\n\r\n\tfunction findEntryOctant(tx0, ty0, tz0, txm, tym, tzm) {\r\n\r\n\t\tlet entry = 0;\r\n\r\n\t\t// Find the entry plane.\r\n\t\tif(tx0 > ty0 && tx0 > tz0) {\r\n\r\n\t\t\t// YZ-plane.\r\n\t\t\tif(tym < tx0) { entry |= 2; }\r\n\t\t\tif(tzm < tx0) { entry |= 1; }\r\n\r\n\t\t} else if(ty0 > tz0) {\r\n\r\n\t\t\t// XZ-plane.\r\n\t\t\tif(txm < ty0) { entry |= 4; }\r\n\t\t\tif(tzm < ty0) { entry |= 1; }\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// XY-plane.\r\n\t\t\tif(txm < tz0) { entry |= 4; }\r\n\t\t\tif(tym < tz0) { entry |= 2; }\r\n\r\n\t\t}\r\n\r\n\t\treturn entry;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Finds the next octant that intersects with the ray based on the exit plane of\r\n\t * the current one.\r\n\t *\r\n\t * @private\r\n\t * @param {Number} currentOctant - The index of the current octant.\r\n\t * @param {Number} tx1 - Ray projection parameter.\r\n\t * @param {Number} ty1 - Ray projection parameter.\r\n\t * @param {Number} tz1 - Ray projection parameter.\r\n\t * @return {Number} The index of the next octant that the ray travels through.\r\n\t */\r\n\r\n\tfunction findNextOctant(currentOctant, tx1, ty1, tz1) {\r\n\r\n\t\tlet min;\r\n\t\tlet exit = 0;\r\n\r\n\t\t// Find the exit plane.\r\n\t\tif(tx1 < ty1) {\r\n\r\n\t\t\tmin = tx1;\r\n\t\t\texit = 0; // YZ-plane.\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin = ty1;\r\n\t\t\texit = 1; // XZ-plane.\r\n\r\n\t\t}\r\n\r\n\t\tif(tz1 < min) {\r\n\r\n\t\t\texit = 2; // XY-plane.\r\n\r\n\t\t}\r\n\r\n\t\treturn octantTable[currentOctant][exit];\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Finds all octants that intersect with the given ray.\r\n\t *\r\n\t * @private\r\n\t * @param {Octant} octant - The current octant.\r\n\t * @param {Number} tx0 - Ray projection parameter. Initial tx0 = (minX - rayOriginX) / rayDirectionX.\r\n\t * @param {Number} ty0 - Ray projection parameter. Initial ty0 = (minY - rayOriginY) / rayDirectionY.\r\n\t * @param {Number} tz0 - Ray projection parameter. Initial tz0 = (minZ - rayOriginZ) / rayDirectionZ.\r\n\t * @param {Number} tx1 - Ray projection parameter. Initial tx1 = (maxX - rayOriginX) / rayDirectionX.\r\n\t * @param {Number} ty1 - Ray projection parameter. Initial ty1 = (maxY - rayOriginY) / rayDirectionY.\r\n\t * @param {Number} tz1 - Ray projection parameter. Initial tz1 = (maxZ - rayOriginZ) / rayDirectionZ.\r\n\t * @param {Raycaster} raycaster - The raycaster.\r\n\t * @param {Array} intersects - An array to be filled with the intersecting octants.\r\n\t */\r\n\r\n\tfunction raycastOctant(octant, tx0, ty0, tz0, tx1, ty1, tz1, raycaster, intersects) {\r\n\r\n\t\tconst children = octant.children;\r\n\r\n\t\tlet currentOctant;\r\n\t\tlet txm, tym, tzm;\r\n\r\n\t\tif(tx1 >= 0.0 && ty1 >= 0.0 && tz1 >= 0.0) {\r\n\r\n\t\t\tif(children === null) {\r\n\r\n\t\t\t\t// Leaf.\r\n\t\t\t\tintersects.push(octant);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Compute means.\r\n\t\t\t\ttxm = 0.5 * (tx0 + tx1);\r\n\t\t\t\ttym = 0.5 * (ty0 + ty1);\r\n\t\t\t\ttzm = 0.5 * (tz0 + tz1);\r\n\r\n\t\t\t\tcurrentOctant = findEntryOctant(tx0, ty0, tz0, txm, tym, tzm);\r\n\r\n\t\t\t\tdo {\r\n\r\n\t\t\t\t\t/* The possibilities for the next node are passed in the same respective\r\n\t\t\t\t\t * order as the t-values. Hence, if the first value is found to be the\r\n\t\t\t\t\t * greatest, the fourth one will be returned. If the second value is the\r\n\t\t\t\t\t * greatest, the fifth one will be returned, etc.\r\n\t\t\t\t\t */\r\n\r\n\t\t\t\t\tswitch(currentOctant) {\r\n\r\n\t\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\t\traycastOctant(children[flags], tx0, ty0, tz0, txm, tym, tzm, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, txm, tym, tzm);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 1], tx0, ty0, tzm, txm, tym, tz1, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, txm, tym, tz1);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 2], tx0, tym, tz0, txm, ty1, tzm, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, txm, ty1, tzm);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 3], tx0, tym, tzm, txm, ty1, tz1, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, txm, ty1, tz1);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 4], txm, ty0, tz0, tx1, tym, tzm, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, tx1, tym, tzm);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 5:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 5], txm, ty0, tzm, tx1, tym, tz1, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, tx1, tym, tz1);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 6], txm, tym, tz0, tx1, ty1, tzm, raycaster, intersects);\r\n\t\t\t\t\t\t\tcurrentOctant = findNextOctant(currentOctant, tx1, ty1, tzm);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 7:\r\n\t\t\t\t\t\t\traycastOctant(children[flags ^ 7], txm, tym, tzm, tx1, ty1, tz1, raycaster, intersects);\r\n\t\t\t\t\t\t\t// Far top right octant. No other octants can be reached from here.\r\n\t\t\t\t\t\t\tcurrentOctant = 8;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} while(currentOctant < 8);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * An octree raycaster.\r\n\t *\r\n\t * Based on:\r\n\t *  \"An Efficient Parametric Algorithm for Octree Traversal\"\r\n\t *  by J. Revelles et al. (2000).\r\n\t */\r\n\r\n\tclass OctreeRaycaster {\r\n\r\n\t\t/**\r\n\t\t * Finds the octants that intersect with the given ray. The intersecting\r\n\t\t * octants are sorted by distance, closest first.\r\n\t\t *\r\n\t\t * @param {Octree} octree - An octree.\r\n\t\t * @param {Raycaster} raycaster - A raycaster.\r\n\t\t * @param {Array} intersects - A list to be filled with intersecting octants.\r\n\t\t */\r\n\r\n\t\tstatic intersectOctree(octree, raycaster, intersects) {\r\n\r\n\t\t\t// Translate the octree extents to the scene origin.\r\n\t\t\tconst min = b$5.min.set(0, 0, 0);\r\n\t\t\tconst max = b$5.max.subVectors(octree.max, octree.min);\r\n\r\n\t\t\tconst dimensions = octree.getDimensions(v$4[0]);\r\n\t\t\tconst halfDimensions = v$4[1].copy(dimensions).multiplyScalar(0.5);\r\n\r\n\t\t\tconst origin = r.origin.copy(raycaster.ray.origin);\r\n\t\t\tconst direction = r.direction.copy(raycaster.ray.direction);\r\n\r\n\t\t\tlet invDirX, invDirY, invDirZ;\r\n\t\t\tlet tx0, tx1, ty0, ty1, tz0, tz1;\r\n\r\n\t\t\t// Translate the ray to the center of the octree.\r\n\t\t\torigin.sub(octree.getCenter(v$4[2])).add(halfDimensions);\r\n\r\n\t\t\t// Reset all flags.\r\n\t\t\tflags = 0;\r\n\r\n\t\t\t// Handle rays with negative directions.\r\n\t\t\tif(direction.x < 0.0) {\r\n\r\n\t\t\t\torigin.x = dimensions.x - origin.x;\r\n\t\t\t\tdirection.x = -direction.x;\r\n\t\t\t\tflags |= 4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(direction.y < 0.0) {\r\n\r\n\t\t\t\torigin.y = dimensions.y - origin.y;\r\n\t\t\t\tdirection.y = -direction.y;\r\n\t\t\t\tflags |= 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(direction.z < 0.0) {\r\n\r\n\t\t\t\torigin.z = dimensions.z - origin.z;\r\n\t\t\t\tdirection.z = -direction.z;\r\n\t\t\t\tflags |= 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Improve IEEE double stability.\r\n\t\t\tinvDirX = 1.0 / direction.x;\r\n\t\t\tinvDirY = 1.0 / direction.y;\r\n\t\t\tinvDirZ = 1.0 / direction.z;\r\n\r\n\t\t\t// Project the ray to the root's boundaries.\r\n\t\t\ttx0 = (min.x - origin.x) * invDirX;\r\n\t\t\ttx1 = (max.x - origin.x) * invDirX;\r\n\t\t\tty0 = (min.y - origin.y) * invDirY;\r\n\t\t\tty1 = (max.y - origin.y) * invDirY;\r\n\t\t\ttz0 = (min.z - origin.z) * invDirZ;\r\n\t\t\ttz1 = (max.z - origin.z) * invDirZ;\r\n\r\n\t\t\t// Check if the ray hits the octree.\r\n\t\t\tif(Math.max(Math.max(tx0, ty0), tz0) < Math.min(Math.min(tx1, ty1), tz1)) {\r\n\r\n\t\t\t\t// Find the intersecting octants.\r\n\t\t\t\traycastOctant(octree.root, tx0, ty0, tz0, tx1, ty1, tz1, raycaster, intersects);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A 3D box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b$3 = new Box3();\r\n\r\n\t/**\r\n\t * Recursively calculates the depth of the given octree.\r\n\t *\r\n\t * @private\r\n\t * @param {Octant} octant - An octant.\r\n\t * @return {Number} The depth.\r\n\t */\r\n\r\n\tfunction getDepth(octant) {\r\n\r\n\t\tconst children = octant.children;\r\n\r\n\t\tlet result = 0;\r\n\t\tlet i, l, d;\r\n\r\n\t\tif(children !== null) {\r\n\r\n\t\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t\td = 1 + getDepth(children[i]);\r\n\r\n\t\t\t\tif(d > result) {\r\n\r\n\t\t\t\t\tresult = d;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Recursively collects octants that lie inside the specified region.\r\n\t *\r\n\t * @private\r\n\t * @param {Octant} octant - An octant.\r\n\t * @param {Frustum|Box3} region - A region.\r\n\t * @param {Octant[]} result - A list to be filled with octants that intersect with the region.\r\n\t */\r\n\r\n\tfunction cull(octant, region, result) {\r\n\r\n\t\tconst children = octant.children;\r\n\r\n\t\tlet i, l;\r\n\r\n\t\tb$3.min = octant.min;\r\n\t\tb$3.max = octant.max;\r\n\r\n\t\tif(region.intersectsBox(b$3)) {\r\n\r\n\t\t\tif(children !== null) {\r\n\r\n\t\t\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t\t\tcull(children[i], region, result);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult.push(octant);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Recursively fetches all octants with the specified depth level.\r\n\t *\r\n\t * @private\r\n\t * @param {Octant} octant - An octant.\r\n\t * @param {Number} level - The target depth level.\r\n\t * @param {Number} depth - The current depth level.\r\n\t * @param {Octant[]} result - A list to be filled with the identified octants.\r\n\t */\r\n\r\n\tfunction findOctantsByLevel(octant, level, depth, result) {\r\n\r\n\t\tconst children = octant.children;\r\n\r\n\t\tlet i, l;\r\n\r\n\t\tif(depth === level) {\r\n\r\n\t\t\tresult.push(octant);\r\n\r\n\t\t} else if(children !== null) {\r\n\r\n\t\t\t++depth;\r\n\r\n\t\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t\tfindOctantsByLevel(children[i], level, depth, result);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * An octree that subdivides space for fast spatial searches.\r\n\t *\r\n\t * @implements {Iterable}\r\n\t */\r\n\r\n\tclass Octree {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new octree.\r\n\t\t *\r\n\t\t * @param {Vector3} [min] - The lower bounds of the tree. If not provided, the octree will not create a root node.\r\n\t\t * @param {Vector3} [max] - The upper bounds of the tree. If not provided, the octree will not create a root node.\r\n\t\t */\r\n\r\n\t\tconstructor(min, max) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The root octant.\r\n\t\t\t *\r\n\t\t\t * @type {Octant}\r\n\t\t\t * @default null\r\n\t\t\t */\r\n\r\n\t\t\tthis.root = (min !== undefined && max !== undefined) ? new Octant(min, max) : null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The lower bounds of the root octant.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tget min() { return this.root.min; }\r\n\r\n\t\t/**\r\n\t\t * The upper bounds of the root octant.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tget max() { return this.root.max; }\r\n\r\n\t\t/**\r\n\t\t * The children of the root octant.\r\n\t\t *\r\n\t\t * @type {Octant[]}\r\n\t\t */\r\n\r\n\t\tget children() { return this.root.children; }\r\n\r\n\t\t/**\r\n\t\t * Calculates the center of this octree.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the center of this octree.\r\n\t\t */\r\n\r\n\t\tgetCenter(target) { return this.root.getCenter(target); }\r\n\r\n\t\t/**\r\n\t\t * Calculates the size of this octree.\r\n\t\t *\r\n\t\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t\t * @return {Vector3} A vector that describes the size of this octree.\r\n\t\t */\r\n\r\n\t\tgetDimensions(target) { return this.root.getDimensions(target); }\r\n\r\n\t\t/**\r\n\t\t * Calculates the current depth of this octree.\r\n\t\t *\r\n\t\t * @return {Number} The depth.\r\n\t\t */\r\n\r\n\t\tgetDepth() { return getDepth(this.root); }\r\n\r\n\t\t/**\r\n\t\t * Recursively collects octants that intersect with the specified region.\r\n\t\t *\r\n\t\t * @param {Frustum|Box3} region - A region.\r\n\t\t * @return {Octant[]} The octants.\r\n\t\t */\r\n\r\n\t\tcull(region) {\r\n\r\n\t\t\tconst result = [];\r\n\r\n\t\t\tcull(this.root, region, result);\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Fetches all octants with the specified depth level.\r\n\t\t *\r\n\t\t * @param {Number} level - The depth level.\r\n\t\t * @return {Octant[]} The octants.\r\n\t\t */\r\n\r\n\t\tfindOctantsByLevel(level) {\r\n\r\n\t\t\tconst result = [];\r\n\r\n\t\t\tfindOctantsByLevel(this.root, level, 0, result);\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds the octants that intersect with the given ray. The intersecting\r\n\t\t * octants are sorted by distance, closest first.\r\n\t\t *\r\n\t\t * @param {Raycaster} raycaster - A raycaster.\r\n\t\t * @param {Octant[]} [intersects] - An optional target list to be filled with the intersecting octants.\r\n\t\t * @return {Octant[]} The intersecting octants.\r\n\t\t */\r\n\r\n\t\traycast(raycaster, intersects = []) {\r\n\r\n\t\t\tOctreeRaycaster.intersectOctree(this, raycaster, intersects);\r\n\r\n\t\t\treturn intersects;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns an iterator that traverses the octree and returns leaf nodes.\r\n\t\t *\r\n\t\t * When a cull region is provided, the iterator will only return leaves that\r\n\t\t * intersect with that region.\r\n\t\t *\r\n\t\t * @param {Frustum|Box3} [region] - A cull region.\r\n\t\t * @return {OctantIterator} An iterator.\r\n\t\t */\r\n\r\n\t\tleaves(region) {\r\n\r\n\t\t\treturn new OctantIterator(this, region);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns an iterator that traverses the octree and returns all leaf nodes.\r\n\t\t *\r\n\t\t * @return {OctantIterator} An iterator.\r\n\t\t */\r\n\r\n\t\t[Symbol.iterator]() {\r\n\r\n\t\t\treturn new OctantIterator(this);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Core components.\r\n\t *\r\n\t * @module sparse-octree/core\r\n\t */\n\n\t/**\r\n\t * A point.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst p = new Vector3();\r\n\r\n\t/**\r\n\t * An octant that maintains points.\r\n\t */\n\n\t/**\r\n\t * A collection of ray-point intersection data.\r\n\t */\n\n\t/**\r\n\t * An octree that manages points.\r\n\t */\n\n\t/**\r\n\t * Point-oriented octree components.\r\n\t *\r\n\t * @module sparse-octree/points\r\n\t */\n\n\t/**\r\n\t * A box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst b$6 = new Box3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst c$3 = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst u = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst v$5 = new Vector3();\r\n\r\n\t/**\r\n\t * A collection of octree utility functions.\r\n\t */\n\n\t/**\r\n\t * Octree utilities.\r\n\t *\r\n\t * @module sparse-octree/utils\r\n\t */\n\n\t/**\r\n\t * Exposure of the library components.\r\n\t *\r\n\t * @module sparse-octree\r\n\t */\n\n\t/**\r\n\t * An enumeration of material constants.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {Number} AIR - Indicates empty space.\r\n\t * @property {Number} SOLID - Indicates solid material.\r\n\t */\r\n\r\n\tconst Material = {\r\n\r\n\t\tAIR: 0,\r\n\t\tSOLID: 1\r\n\r\n\t};\n\n\t/**\r\n\t * An isosurface, the result of a contouring process.\r\n\t *\r\n\t * @implements {Serializable}\r\n\t * @implements {Deserializable}\r\n\t * @implements {TransferableContainer}\r\n\t */\r\n\r\n\tclass Isosurface {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new isosurface.\r\n\t\t *\r\n\t\t * @param {Uint16Array} indices - Triangle indices.\r\n\t\t * @param {Float32Array} positions - Generated vertices.\r\n\t\t * @param {Float32Array} normals - Generated normals.\r\n\t\t * @param {Float32Array} uvs - Generated uvs.\r\n\t\t * @param {Uint8Array} materials - Generated materials.\r\n\t\t */\r\n\r\n\t\tconstructor(indices, positions, normals, uvs, materials) {\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of vertex indices that describe triangles.\r\n\t\t\t *\r\n\t\t\t * @type {Uint16Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.indices = indices;\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of vertices.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.positions = positions;\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of normals.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.normals = normals;\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of UV coordinates.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.uvs = uvs;\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of material indices.\r\n\t\t\t *\r\n\t\t\t * @type {Uint8Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.materials = materials;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Serialises this isosurface.\r\n\t\t *\r\n\t\t * @param {Boolean} [deflate=false] - Whether the data should be compressed if possible.\r\n\t\t * @return {Object} The serialised data.\r\n\t\t */\r\n\r\n\t\tserialize(deflate = false) {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tindices: this.indices,\r\n\t\t\t\tpositions: this.positions,\r\n\t\t\t\tnormals: this.normals,\r\n\t\t\t\tuvs: this.uvs,\r\n\t\t\t\tmaterials: this.materials\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the given serialised isosurface.\r\n\t\t *\r\n\t\t * @param {Object} object - A serialised isosurface. Can be null.\r\n\t\t * @return {Deserializable} This object or null if the given serialised isosurface was null.\r\n\t\t */\r\n\r\n\t\tdeserialize(object) {\r\n\r\n\t\t\tlet result = this;\r\n\r\n\t\t\tif(object !== null) {\r\n\r\n\t\t\t\tthis.indices = object.indices;\r\n\t\t\t\tthis.positions = object.positions;\r\n\t\t\t\tthis.normals = object.normals;\r\n\t\t\t\tthis.uvs = object.uvs;\r\n\t\t\t\tthis.materials = object.materials;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a list of transferable items.\r\n\t\t *\r\n\t\t * @param {Array} [transferList] - An optional target list. The transferable items will be added to this list.\r\n\t\t * @return {Transferable[]} The transfer list.\r\n\t\t */\r\n\r\n\t\tcreateTransferList(transferList = []) {\r\n\r\n\t\t\ttransferList.push(this.indices.buffer);\r\n\t\t\ttransferList.push(this.positions.buffer);\r\n\t\t\ttransferList.push(this.normals.buffer);\r\n\t\t\ttransferList.push(this.uvs.buffer);\r\n\t\t\ttransferList.push(this.materials.buffer);\r\n\r\n\t\t\treturn transferList;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * An edge mask.\r\n\t *\r\n\t * @type {Uint8Array}\r\n\t */\r\n\r\n\r\n\r\n\t/**\r\n\t * A face map.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t */\r\n\r\n\r\n\r\n\t/**\r\n\t * A face mask for cell processing.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t */\r\n\r\n\tconst cellProcFaceMask = [\r\n\r\n\t\tnew Uint8Array([0, 4, 0]),\r\n\t\tnew Uint8Array([1, 5, 0]),\r\n\t\tnew Uint8Array([2, 6, 0]),\r\n\t\tnew Uint8Array([3, 7, 0]),\r\n\t\tnew Uint8Array([0, 2, 1]),\r\n\t\tnew Uint8Array([4, 6, 1]),\r\n\t\tnew Uint8Array([1, 3, 1]),\r\n\t\tnew Uint8Array([5, 7, 1]),\r\n\t\tnew Uint8Array([0, 1, 2]),\r\n\t\tnew Uint8Array([2, 3, 2]),\r\n\t\tnew Uint8Array([4, 5, 2]),\r\n\t\tnew Uint8Array([6, 7, 2])\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * An edge mask for cell processing.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t */\r\n\r\n\tconst cellProcEdgeMask = [\r\n\r\n\t\tnew Uint8Array([0, 1, 2, 3, 0]),\r\n\t\tnew Uint8Array([4, 5, 6, 7, 0]),\r\n\t\tnew Uint8Array([0, 4, 1, 5, 1]),\r\n\t\tnew Uint8Array([2, 6, 3, 7, 1]),\r\n\t\tnew Uint8Array([0, 2, 4, 6, 2]),\r\n\t\tnew Uint8Array([1, 3, 5, 7, 2])\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * A face mask for face processing.\r\n\t *\r\n\t * @type {Array<Uint8Array[]>}\r\n\t */\r\n\r\n\tconst faceProcFaceMask = [\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([4, 0, 0]),\r\n\t\t\tnew Uint8Array([5, 1, 0]),\r\n\t\t\tnew Uint8Array([6, 2, 0]),\r\n\t\t\tnew Uint8Array([7, 3, 0])\r\n\t\t],\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([2, 0, 1]),\r\n\t\t\tnew Uint8Array([6, 4, 1]),\r\n\t\t\tnew Uint8Array([3, 1, 1]),\r\n\t\t\tnew Uint8Array([7, 5, 1])\r\n\t\t],\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([1, 0, 2]),\r\n\t\t\tnew Uint8Array([3, 2, 2]),\r\n\t\t\tnew Uint8Array([5, 4, 2]),\r\n\t\t\tnew Uint8Array([7, 6, 2])\r\n\t\t]\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * An edge mask for face processing.\r\n\t *\r\n\t * @type {Array<Uint8Array[]>}\r\n\t */\r\n\r\n\tconst faceProcEdgeMask = [\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([1, 4, 0, 5, 1, 1]),\r\n\t\t\tnew Uint8Array([1, 6, 2, 7, 3, 1]),\r\n\t\t\tnew Uint8Array([0, 4, 6, 0, 2, 2]),\r\n\t\t\tnew Uint8Array([0, 5, 7, 1, 3, 2])\r\n\t\t],\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([0, 2, 3, 0, 1, 0]),\r\n\t\t\tnew Uint8Array([0, 6, 7, 4, 5, 0]),\r\n\t\t\tnew Uint8Array([1, 2, 0, 6, 4, 2]),\r\n\t\t\tnew Uint8Array([1, 3, 1, 7, 5, 2])\r\n\t\t],\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([1, 1, 0, 3, 2, 0]),\r\n\t\t\tnew Uint8Array([1, 5, 4, 7, 6, 0]),\r\n\t\t\tnew Uint8Array([0, 1, 5, 0, 4, 1]),\r\n\t\t\tnew Uint8Array([0, 3, 7, 2, 6, 1])\r\n\t\t]\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * An edge mask for edge processing.\r\n\t *\r\n\t * @type {Array<Uint8Array[]>}\r\n\t */\r\n\r\n\tconst edgeProcEdgeMask = [\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([3, 2, 1, 0, 0]),\r\n\t\t\tnew Uint8Array([7, 6, 5, 4, 0])\r\n\t\t],\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([5, 1, 4, 0, 1]),\r\n\t\t\tnew Uint8Array([7, 3, 6, 2, 1])\r\n\t\t],\r\n\r\n\t\t[\r\n\t\t\tnew Uint8Array([6, 4, 2, 0, 2]),\r\n\t\t\tnew Uint8Array([7, 5, 3, 1, 2])\r\n\t\t]\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * An edge mask.\r\n\t *\r\n\t * @type {Uint8Array[]}\r\n\t */\r\n\r\n\tconst procEdgeMask = [\r\n\r\n\t\tnew Uint8Array([3, 2, 1, 0]),\r\n\t\tnew Uint8Array([7, 5, 6, 4]),\r\n\t\tnew Uint8Array([11, 10, 9, 8])\r\n\r\n\t];\n\n\t/**\r\n\t * The maximum number of vertices. Vertex indices use 16 bits.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst MAX_VERTEX_COUNT = Math.pow(2, 16) - 1;\r\n\r\n\t/**\r\n\t * An edge contouring sub-procedure.\r\n\t *\r\n\t * @private\r\n\t * @param {Array} octants - Four leaf octants.\r\n\t * @param {Number} dir - A direction index.\r\n\t * @param {Array} indexBuffer - An output list for vertex indices.\r\n\t */\r\n\r\n\tfunction contourProcessEdge(octants, dir, indexBuffer) {\r\n\r\n\t\tconst indices = [-1, -1, -1, -1];\r\n\t\tconst signChange = [false, false, false, false];\r\n\r\n\t\tlet minSize = Infinity;\r\n\t\tlet minIndex = 0;\r\n\t\tlet flip = false;\r\n\r\n\t\tlet c1, c2, m1, m2;\r\n\t\tlet octant, edge;\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; i < 4; ++i) {\r\n\r\n\t\t\toctant = octants[i];\r\n\t\t\tedge = procEdgeMask[dir][i];\r\n\r\n\t\t\tc1 = edges[edge][0];\r\n\t\t\tc2 = edges[edge][1];\r\n\r\n\t\t\tm1 = (octant.voxel.materials >> c1) & 1;\r\n\t\t\tm2 = (octant.voxel.materials >> c2) & 1;\r\n\r\n\t\t\tif(octant.size < minSize) {\r\n\r\n\t\t\t\tminSize = octant.size;\r\n\t\t\t\tminIndex = i;\r\n\t\t\t\tflip = (m1 !== Material.AIR);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindices[i] = octant.voxel.index;\r\n\t\t\tsignChange[i] = (m1 !== m2);\r\n\r\n\t\t}\r\n\r\n\t\tif(signChange[minIndex]) {\r\n\r\n\t\t\tif(!flip) {\r\n\r\n\t\t\t\tindexBuffer.push(indices[0]);\r\n\t\t\t\tindexBuffer.push(indices[1]);\r\n\t\t\t\tindexBuffer.push(indices[3]);\r\n\r\n\t\t\t\tindexBuffer.push(indices[0]);\r\n\t\t\t\tindexBuffer.push(indices[3]);\r\n\t\t\t\tindexBuffer.push(indices[2]);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindexBuffer.push(indices[0]);\r\n\t\t\t\tindexBuffer.push(indices[3]);\r\n\t\t\t\tindexBuffer.push(indices[1]);\r\n\r\n\t\t\t\tindexBuffer.push(indices[0]);\r\n\t\t\t\tindexBuffer.push(indices[2]);\r\n\t\t\t\tindexBuffer.push(indices[3]);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * An edge contouring procedure.\r\n\t *\r\n\t * @private\r\n\t * @param {Array} octants - Four edge octants.\r\n\t * @param {Number} dir - A direction index.\r\n\t * @param {Array} indexBuffer - An output list for vertex indices.\r\n\t */\r\n\r\n\tfunction contourEdgeProc(octants, dir, indexBuffer) {\r\n\r\n\t\tconst c = [0, 0, 0, 0];\r\n\r\n\t\tlet edgeOctants;\r\n\t\tlet octant;\r\n\t\tlet i, j;\r\n\r\n\t\tif(octants[0].voxel !== null && octants[1].voxel !== null &&\r\n\t\t\toctants[2].voxel !== null && octants[3].voxel !== null) {\r\n\r\n\t\t\tcontourProcessEdge(octants, dir, indexBuffer);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor(i = 0; i < 2; ++i) {\r\n\r\n\t\t\t\tc[0] = edgeProcEdgeMask[dir][i][0];\r\n\t\t\t\tc[1] = edgeProcEdgeMask[dir][i][1];\r\n\t\t\t\tc[2] = edgeProcEdgeMask[dir][i][2];\r\n\t\t\t\tc[3] = edgeProcEdgeMask[dir][i][3];\r\n\r\n\t\t\t\tedgeOctants = [];\r\n\r\n\t\t\t\tfor(j = 0; j < 4; ++j) {\r\n\r\n\t\t\t\t\toctant = octants[j];\r\n\r\n\t\t\t\t\tif(octant.voxel !== null) {\r\n\r\n\t\t\t\t\t\tedgeOctants[j] = octant;\r\n\r\n\t\t\t\t\t} else if(octant.children !== null) {\r\n\r\n\t\t\t\t\t\tedgeOctants[j] = octant.children[c[j]];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(j === 4) {\r\n\r\n\t\t\t\t\tcontourEdgeProc(edgeOctants, edgeProcEdgeMask[dir][i][4], indexBuffer);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A face contouring procedure.\r\n\t *\r\n\t * @private\r\n\t * @param {Array} octants - Two face octants.\r\n\t * @param {Number} dir - A direction index.\r\n\t * @param {Array} indexBuffer - An output list for vertex indices.\r\n\t */\r\n\r\n\tfunction contourFaceProc(octants, dir, indexBuffer) {\r\n\r\n\t\tconst c = [0, 0, 0, 0];\r\n\r\n\t\tconst orders = [\r\n\t\t\t[0, 0, 1, 1],\r\n\t\t\t[0, 1, 0, 1]\r\n\t\t];\r\n\r\n\t\tlet faceOctants, edgeOctants;\r\n\t\tlet order, octant;\r\n\t\tlet i, j;\r\n\r\n\t\tif(octants[0].children !== null || octants[1].children !== null) {\r\n\r\n\t\t\tfor(i = 0; i < 4; ++i) {\r\n\r\n\t\t\t\tc[0] = faceProcFaceMask[dir][i][0];\r\n\t\t\t\tc[1] = faceProcFaceMask[dir][i][1];\r\n\r\n\t\t\t\tfaceOctants = [\r\n\t\t\t\t\t(octants[0].children === null) ? octants[0] : octants[0].children[c[0]],\r\n\t\t\t\t\t(octants[1].children === null) ? octants[1] : octants[1].children[c[1]]\r\n\t\t\t\t];\r\n\r\n\t\t\t\tcontourFaceProc(faceOctants, faceProcFaceMask[dir][i][2], indexBuffer);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor(i = 0; i < 4; ++i) {\r\n\r\n\t\t\t\tc[0] = faceProcEdgeMask[dir][i][1];\r\n\t\t\t\tc[1] = faceProcEdgeMask[dir][i][2];\r\n\t\t\t\tc[2] = faceProcEdgeMask[dir][i][3];\r\n\t\t\t\tc[3] = faceProcEdgeMask[dir][i][4];\r\n\r\n\t\t\t\torder = orders[faceProcEdgeMask[dir][i][0]];\r\n\r\n\t\t\t\tedgeOctants = [];\r\n\r\n\t\t\t\tfor(j = 0; j < 4; ++j) {\r\n\r\n\t\t\t\t\toctant = octants[order[j]];\r\n\r\n\t\t\t\t\tif(octant.voxel !== null) {\r\n\r\n\t\t\t\t\t\tedgeOctants[j] = octant;\r\n\r\n\t\t\t\t\t} else if(octant.children !== null) {\r\n\r\n\t\t\t\t\t\tedgeOctants[j] = octant.children[c[j]];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(j === 4) {\r\n\r\n\t\t\t\t\tcontourEdgeProc(edgeOctants, faceProcEdgeMask[dir][i][5], indexBuffer);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * The main contouring procedure.\r\n\t *\r\n\t * @private\r\n\t * @param {Octant} octant - An octant.\r\n\t * @param {Array} indexBuffer - An output list for vertex indices.\r\n\t */\r\n\r\n\tfunction contourCellProc(octant, indexBuffer) {\r\n\r\n\t\tconst children = octant.children;\r\n\t\tconst c = [0, 0, 0, 0];\r\n\r\n\t\tlet faceOctants, edgeOctants;\r\n\t\tlet i;\r\n\r\n\t\tif(children !== null) {\r\n\r\n\t\t\tfor(i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\tcontourCellProc(children[i], indexBuffer);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor(i = 0; i < 12; ++i) {\r\n\r\n\t\t\t\tc[0] = cellProcFaceMask[i][0];\r\n\t\t\t\tc[1] = cellProcFaceMask[i][1];\r\n\r\n\t\t\t\tfaceOctants = [\r\n\t\t\t\t\tchildren[c[0]],\r\n\t\t\t\t\tchildren[c[1]]\r\n\t\t\t\t];\r\n\r\n\t\t\t\tcontourFaceProc(faceOctants, cellProcFaceMask[i][2], indexBuffer);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor(i = 0; i < 6; ++i) {\r\n\r\n\t\t\t\tc[0] = cellProcEdgeMask[i][0];\r\n\t\t\t\tc[1] = cellProcEdgeMask[i][1];\r\n\t\t\t\tc[2] = cellProcEdgeMask[i][2];\r\n\t\t\t\tc[3] = cellProcEdgeMask[i][3];\r\n\r\n\t\t\t\tedgeOctants = [\r\n\t\t\t\t\tchildren[c[0]],\r\n\t\t\t\t\tchildren[c[1]],\r\n\t\t\t\t\tchildren[c[2]],\r\n\t\t\t\t\tchildren[c[3]]\r\n\t\t\t\t];\r\n\r\n\t\t\t\tcontourEdgeProc(edgeOctants, cellProcEdgeMask[i][4], indexBuffer);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Collects positions and normals from the voxel information of the given octant\r\n\t * and its children. The generated vertex indices are stored in the respective\r\n\t * voxels during the octree traversal.\r\n\t *\r\n\t * @private\r\n\t * @param {Octant} octant - An octant.\r\n\t * @param {Array} vertexBuffer - An array to be filled with vertices.\r\n\t * @param {Array} normalBuffer - An array to be filled with normals.\r\n\t * @param {Number} index - The next vertex index.\r\n\t */\r\n\r\n\tfunction generateVertexIndices(octant, positions, normals, index) {\r\n\r\n\t\tlet i, voxel;\r\n\r\n\t\tif(octant.children !== null) {\r\n\r\n\t\t\tfor(i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\tindex = generateVertexIndices(octant.children[i], positions, normals, index);\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if(octant.voxel !== null) {\r\n\r\n\t\t\tvoxel = octant.voxel;\r\n\t\t\tvoxel.index = index;\r\n\r\n\t\t\tpositions[index * 3] = voxel.position.x;\r\n\t\t\tpositions[index * 3 + 1] = voxel.position.y;\r\n\t\t\tpositions[index * 3 + 2] = voxel.position.z;\r\n\r\n\t\t\tnormals[index * 3] = voxel.normal.x;\r\n\t\t\tnormals[index * 3 + 1] = voxel.normal.y;\r\n\t\t\tnormals[index * 3 + 2] = voxel.normal.z;\r\n\r\n\t\t\t++index;\r\n\r\n\t\t}\r\n\r\n\t\treturn index;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Dual Contouring is an isosurface extraction technique that was originally\r\n\t * presented by Tao Ju in 2002:\r\n\t *  http://www.cs.wustl.edu/~taoju/research/dualContour.pdf\r\n\t */\r\n\r\n\tclass DualContouring {\r\n\r\n\t\t/**\r\n\t\t * Contours the given volume data.\r\n\t\t *\r\n\t\t * @param {SparseVoxelOctree} octree - A voxel octree.\r\n\t\t * @return {Isosurface} The generated isosurface or null if no data was generated.\r\n\t\t */\r\n\r\n\t\tstatic run(octree) {\r\n\r\n\t\t\tconst indexBuffer = [];\r\n\r\n\t\t\t// Each voxel contains one vertex.\r\n\t\t\tconst vertexCount = octree.voxelCount;\r\n\r\n\t\t\tlet result = null;\r\n\t\t\tlet positions = null;\r\n\t\t\tlet normals = null;\r\n\t\t\tlet uvs = null;\r\n\t\t\tlet materials = null;\r\n\r\n\t\t\tif(vertexCount > MAX_VERTEX_COUNT) {\r\n\r\n\t\t\t\tconsole.warn(\r\n\t\t\t\t\t\"Could not create geometry for cell at position\", octree.min,\r\n\t\t\t\t\t\"(vertex count of\", vertexCount, \"exceeds limit of \", MAX_VERTEX_COUNT, \")\"\r\n\t\t\t\t);\r\n\r\n\t\t\t} else if(vertexCount > 0) {\r\n\r\n\t\t\t\tpositions = new Float32Array(vertexCount * 3);\r\n\t\t\t\tnormals = new Float32Array(vertexCount * 3);\r\n\t\t\t\tuvs = new Float32Array(vertexCount * 2);\r\n\t\t\t\tmaterials = new Uint8Array(vertexCount);\r\n\r\n\t\t\t\tgenerateVertexIndices(octree.root, positions, normals, 0);\r\n\t\t\t\tcontourCellProc(octree.root, indexBuffer);\r\n\r\n\t\t\t\tresult = new Isosurface(\r\n\t\t\t\t\tnew Uint16Array(indexBuffer),\r\n\t\t\t\t\tpositions,\r\n\t\t\t\t\tnormals,\r\n\t\t\t\t\tuvs,\r\n\t\t\t\t\tmaterials\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Isosurface extraction algorithms.\r\n\t *\r\n\t * @module rabbit-hole/isosurface\r\n\t */\n\n\t/**\r\n\t * A load event.\r\n\t *\r\n\t * This event is dispatched by {@link SDFLoader}.\r\n\t *\r\n\t * @type {SDFLoaderEvent}\r\n\t * @example sdfLoader.addEventListener(\"load\", myListener);\r\n\t */\r\n\r\n\tconst load = new SDFLoaderEvent(\"load\");\n\n\t/**\r\n\t * An SDF loader.\r\n\t *\r\n\t * @implements {EventListener}\r\n\t */\n\n\t/**\r\n\t * A collection of loaders.\r\n\t *\r\n\t * @module rabbit-hole/loaders\r\n\t */\n\n\t/**\r\n\t * Symmetric Givens coefficients.\r\n\t *\r\n\t * @type {Vector2}\r\n\t * @private\r\n\t */\r\n\r\n\tconst coefficients = new Vector2();\r\n\r\n\t/**\r\n\t * A collection of matrix rotation utilities.\r\n\t */\r\n\r\n\tclass Givens {\r\n\r\n\t\t/**\r\n\t\t * Calculates symmetric Givens coefficients.\r\n\t\t *\r\n\t\t * @param {Number} aPP - PP.\r\n\t\t * @param {Number} aPQ - PQ.\r\n\t\t * @param {Number} aQQ - QQ.\r\n\t\t * @return {Vector2} The coefficients C and S.\r\n\t\t */\r\n\r\n\t\tstatic calculateCoefficients(aPP, aPQ, aQQ) {\r\n\r\n\t\t\tlet tau, stt, tan;\r\n\r\n\t\t\tif(aPQ === 0.0) {\r\n\r\n\t\t\t\tcoefficients.x = 1.0;\r\n\t\t\t\tcoefficients.y = 0.0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttau = (aQQ - aPP) / (2.0 * aPQ);\r\n\t\t\t\tstt = Math.sqrt(1.0 + tau * tau);\r\n\t\t\t\ttan = 1.0 / ((tau >= 0.0) ? (tau + stt) : (tau - stt));\r\n\r\n\t\t\t\tcoefficients.x = 1.0 / Math.sqrt(1.0 + tan * tan);\r\n\t\t\t\tcoefficients.y = tan * coefficients.x;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn coefficients;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A collection of matrix rotation utilities.\r\n\t */\r\n\r\n\tclass Schur {\r\n\r\n\t\t/**\r\n\t\t * Rotates the given matrix.\r\n\t\t *\r\n\t\t * @param {Vector2} a - The vector that should be rotated.\r\n\t\t * @param {Vector2} coefficients - Givens coefficients.\r\n\t\t */\r\n\r\n\t\tstatic rotateXY(a, coefficients) {\r\n\r\n\t\t\tconst c = coefficients.x;\r\n\t\t\tconst s = coefficients.y;\r\n\r\n\t\t\tconst u = a.x;\r\n\t\t\tconst v = a.y;\r\n\r\n\t\t\ta.set(\r\n\t\t\t\tc * u - s * v,\r\n\t\t\t\ts * u + c * v\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Rotates the given matrix.\r\n\t\t *\r\n\t\t * @param {Vector2} a - The vector that should be rotated.\r\n\t\t * @param {Vector2} q - A coefficient factor.\r\n\t\t * @param {Vector2} coefficients - Givens coefficients.\r\n\t\t */\r\n\r\n\t\tstatic rotateQXY(a, q, coefficients) {\r\n\r\n\t\t\tconst c = coefficients.x;\r\n\t\t\tconst s = coefficients.y;\r\n\t\t\tconst cc = c * c;\r\n\t\t\tconst ss = s * s;\r\n\r\n\t\t\tconst mx = 2.0 * c * s * q;\r\n\r\n\t\t\tconst u = a.x;\r\n\t\t\tconst v = a.y;\r\n\r\n\t\t\ta.set(\r\n\t\t\t\tcc * u - mx + ss * v,\r\n\t\t\t\tss * u + mx + cc * v\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A threshold for pseudo inversions.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst PSEUDOINVERSE_THRESHOLD = 1e-1;\r\n\r\n\t/**\r\n\t * The number of SVD sweeps.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst SVD_SWEEPS = 5;\r\n\r\n\t/**\r\n\t * A symmetric matrix.\r\n\t *\r\n\t * @type {SymmetricMatrix3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst sm = new SymmetricMatrix3();\r\n\r\n\t/**\r\n\t * A matrix.\r\n\t *\r\n\t * @type {Matrix3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst m$1 = new Matrix3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector2}\r\n\t * @private\r\n\t */\r\n\r\n\tconst a$3 = new Vector2();\r\n\r\n\t/**\r\n\t * A vector that holds the singular values.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b$7 = new Vector3();\r\n\r\n\t/**\r\n\t * Rotates the matrix element from the first row, second column.\r\n\t *\r\n\t * @private\r\n\t * @param {SymmetricMatrix3} vtav - A symmetric matrix.\r\n\t * @param {Matrix3} v - A matrix.\r\n\t */\r\n\r\n\tfunction rotate01(vtav, v) {\r\n\r\n\t\tconst se = vtav.elements;\r\n\t\tconst ve = v.elements;\r\n\r\n\t\tlet coefficients;\r\n\r\n\t\tif(se[1] !== 0.0) {\r\n\r\n\t\t\tcoefficients = Givens.calculateCoefficients(se[0], se[1], se[3]);\r\n\r\n\t\t\tSchur.rotateQXY(a$3.set(se[0], se[3]), se[1], coefficients);\r\n\t\t\tse[0] = a$3.x; se[3] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(se[2], se[4]), coefficients);\r\n\t\t\tse[2] = a$3.x; se[4] = a$3.y;\r\n\r\n\t\t\tse[1] = 0.0;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[0], ve[3]), coefficients);\r\n\t\t\tve[0] = a$3.x; ve[3] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[1], ve[4]), coefficients);\r\n\t\t\tve[1] = a$3.x; ve[4] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[2], ve[5]), coefficients);\r\n\t\t\tve[2] = a$3.x; ve[5] = a$3.y;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Rotates the matrix element from the first row, third column.\r\n\t *\r\n\t * @private\r\n\t * @param {SymmetricMatrix3} vtav - A symmetric matrix.\r\n\t * @param {Matrix3} v - A matrix.\r\n\t */\r\n\r\n\tfunction rotate02(vtav, v) {\r\n\r\n\t\tconst se = vtav.elements;\r\n\t\tconst ve = v.elements;\r\n\r\n\t\tlet coefficients;\r\n\r\n\t\tif(se[2] !== 0.0) {\r\n\r\n\t\t\tcoefficients = Givens.calculateCoefficients(se[0], se[2], se[5]);\r\n\r\n\t\t\tSchur.rotateQXY(a$3.set(se[0], se[5]), se[2], coefficients);\r\n\t\t\tse[0] = a$3.x; se[5] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(se[1], se[4]), coefficients);\r\n\t\t\tse[1] = a$3.x; se[4] = a$3.y;\r\n\r\n\t\t\tse[2] = 0.0;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[0], ve[6]), coefficients);\r\n\t\t\tve[0] = a$3.x; ve[6] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[1], ve[7]), coefficients);\r\n\t\t\tve[1] = a$3.x; ve[7] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[2], ve[8]), coefficients);\r\n\t\t\tve[2] = a$3.x; ve[8] = a$3.y;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Rotates the matrix element from the second row, third column.\r\n\t *\r\n\t * @private\r\n\t * @param {SymmetricMatrix3} vtav - A symmetric matrix.\r\n\t * @param {Matrix3} v - A matrix.\r\n\t */\r\n\r\n\tfunction rotate12(vtav, v) {\r\n\r\n\t\tconst se = vtav.elements;\r\n\t\tconst ve = v.elements;\r\n\r\n\t\tlet coefficients;\r\n\r\n\t\tif(se[4] !== 0.0) {\r\n\r\n\t\t\tcoefficients = Givens.calculateCoefficients(se[3], se[4], se[5]);\r\n\r\n\t\t\tSchur.rotateQXY(a$3.set(se[3], se[5]), se[4], coefficients);\r\n\t\t\tse[3] = a$3.x; se[5] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(se[1], se[2]), coefficients);\r\n\t\t\tse[1] = a$3.x; se[2] = a$3.y;\r\n\r\n\t\t\tse[4] = 0.0;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[3], ve[6]), coefficients);\r\n\t\t\tve[3] = a$3.x; ve[6] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[4], ve[7]), coefficients);\r\n\t\t\tve[4] = a$3.x; ve[7] = a$3.y;\r\n\r\n\t\t\tSchur.rotateXY(a$3.set(ve[5], ve[8]), coefficients);\r\n\t\t\tve[5] = a$3.x; ve[8] = a$3.y;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the singular values.\r\n\t *\r\n\t * @private\r\n\t * @param {SymmetricMatrix3} vtav - A symmetric matrix.\r\n\t * @param {Matrix3} v - An identity matrix.\r\n\t * @return {Vector3} The singular values.\r\n\t */\r\n\r\n\tfunction solveSymmetric(vtav, v) {\r\n\r\n\t\tconst e = vtav.elements;\r\n\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; i < SVD_SWEEPS; ++i) {\r\n\r\n\t\t\t// Rotate the upper right (lower left) triagonal.\r\n\t\t\trotate01(vtav, v);\r\n\t\t\trotate02(vtav, v);\r\n\t\t\trotate12(vtav, v);\r\n\r\n\t\t}\r\n\r\n\t\treturn b$7.set(e[0], e[3], e[5]);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the pseudo inverse of a given value.\r\n\t *\r\n\t * @private\r\n\t * @param {Number} x - The value to invert.\r\n\t * @return {Number} The inverted value.\r\n\t */\r\n\r\n\tfunction invert(x) {\r\n\r\n\t\tconst invX = (Math.abs(x) < PSEUDOINVERSE_THRESHOLD) ? 0.0 : 1.0 / x;\r\n\r\n\t\treturn (Math.abs(invX) < PSEUDOINVERSE_THRESHOLD) ? 0.0 : invX;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the pseudo inverse of v using the singular values.\r\n\t *\r\n\t * @private\r\n\t * @param {Matrix3} v - A matrix.\r\n\t * @param {Vector3} sigma - The singular values.\r\n\t * @return {Matrix3} The inverted matrix.\r\n\t */\r\n\r\n\tfunction pseudoInverse(v, sigma) {\r\n\r\n\t\tconst ve = v.elements;\r\n\r\n\t\tconst v00 = ve[0], v01 = ve[3], v02 = ve[6];\r\n\t\tconst v10 = ve[1], v11 = ve[4], v12 = ve[7];\r\n\t\tconst v20 = ve[2], v21 = ve[5], v22 = ve[8];\r\n\r\n\t\tconst d0 = invert(sigma.x);\r\n\t\tconst d1 = invert(sigma.y);\r\n\t\tconst d2 = invert(sigma.z);\r\n\r\n\t\treturn v.set(\r\n\r\n\t\t\t// First row.\r\n\t\t\tv00 * d0 * v00 + v01 * d1 * v01 + v02 * d2 * v02,\r\n\t\t\tv00 * d0 * v10 + v01 * d1 * v11 + v02 * d2 * v12,\r\n\t\t\tv00 * d0 * v20 + v01 * d1 * v21 + v02 * d2 * v22,\r\n\r\n\t\t\t// Second row.\r\n\t\t\tv10 * d0 * v00 + v11 * d1 * v01 + v12 * d2 * v02,\r\n\t\t\tv10 * d0 * v10 + v11 * d1 * v11 + v12 * d2 * v12,\r\n\t\t\tv10 * d0 * v20 + v11 * d1 * v21 + v12 * d2 * v22,\r\n\r\n\t\t\t// Third row.\r\n\t\t\tv20 * d0 * v00 + v21 * d1 * v01 + v22 * d2 * v02,\r\n\t\t\tv20 * d0 * v10 + v21 * d1 * v11 + v22 * d2 * v12,\r\n\t\t\tv20 * d0 * v20 + v21 * d1 * v21 + v22 * d2 * v22\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A Singular Value Decomposition solver.\r\n\t *\r\n\t * Decomposes the given linear system into the matrices U, D and V and solves\r\n\t * the equation: U D V^T x = b.\r\n\t *\r\n\t * See http://mathworld.wolfram.com/SingularValueDecomposition.html for more\r\n\t * information.\r\n\t */\r\n\r\n\tclass SingularValueDecomposition {\r\n\r\n\t\t/**\r\n\t\t * Performs the Singular Value Decomposition to solve the given linear system.\r\n\t\t *\r\n\t\t * @param {SymmetricMatrix3} ata - ATA. Will not be modified.\r\n\t\t * @param {Vector3} atb - ATb. Will not be modified.\r\n\t\t * @param {Vector3} x - A target vector to store the result in.\r\n\t\t */\r\n\r\n\t\tstatic solve(ata, atb, x) {\r\n\r\n\t\t\tconst sigma = solveSymmetric(sm.copy(ata), m$1.identity());\r\n\t\t\tconst invV = pseudoInverse(m$1, sigma);\r\n\r\n\t\t\tx.copy(atb).applyMatrix3(invV);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A point.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst p$1 = new Vector3();\r\n\r\n\t/**\r\n\t * Computes the error of the approximated position.\r\n\t *\r\n\t * @private\r\n\t * @param {SymmetricMatrix3} ata - ATA.\r\n\t * @param {Vector3} atb - ATb.\r\n\t * @param {Vector3} x - The calculated vertex position.\r\n\t * @return {Number} The QEF error.\r\n\t */\r\n\r\n\tfunction calculateError(ata, atb, x) {\r\n\r\n\t\tata.applyToVector3(p$1.copy(x));\r\n\t\tp$1.subVectors(atb, p$1);\r\n\r\n\t\treturn p$1.dot(p$1);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A Quaratic Error Function solver.\r\n\t *\r\n\t * Finds a point inside a voxel that minimises the sum of the squares of the\r\n\t * distances to the surface intersection planes associated with the voxel.\r\n\t *\r\n\t * Based on an implementation by Leonard Ritter and Nick Gildea:\r\n\t *  https://github.com/nickgildea/qef\r\n\t */\r\n\r\n\tclass QEFSolver {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new QEF solver.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\t/**\r\n\t\t\t * QEF data. Will be used destructively.\r\n\t\t\t *\r\n\t\t\t * @type {QEFData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * ATA.\r\n\t\t\t *\r\n\t\t\t * @type {SymmetricMatrix3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.ata = new SymmetricMatrix3();\r\n\r\n\t\t\t/**\r\n\t\t\t * ATb.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.atb = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * The mass point of the current QEF data set.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.massPoint = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * Indicates whether this solver has a solution.\r\n\t\t\t *\r\n\t\t\t * @type {Boolean}\r\n\t\t\t */\r\n\r\n\t\t\tthis.hasSolution = false;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the QEF data.\r\n\t\t *\r\n\t\t * @param {QEFData} d - QEF Data.\r\n\t\t * @return {QEFSolver} This solver.\r\n\t\t */\r\n\r\n\t\tsetData(d) {\r\n\r\n\t\t\tthis.data = d;\r\n\t\t\tthis.hasSolution = false;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Solves the Quadratic Error Function.\r\n\t\t *\r\n\t\t * @param {Vector3} x - A target vector to store the vertex position in.\r\n\t\t * @return {Number} The quadratic error of the solution.\r\n\t\t */\r\n\r\n\t\tsolve(x) {\r\n\r\n\t\t\tconst data = this.data;\r\n\t\t\tconst massPoint = this.massPoint;\r\n\t\t\tconst ata = this.ata.copy(data.ata);\r\n\t\t\tconst atb = this.atb.copy(data.atb);\r\n\r\n\t\t\tlet error = Infinity;\r\n\r\n\t\t\tif(!this.hasSolution && data !== null && data.numPoints > 0) {\r\n\r\n\t\t\t\t// Divide the mass point sum to get the average.\r\n\t\t\t\tp$1.copy(data.massPointSum).divideScalar(data.numPoints);\r\n\t\t\t\tmassPoint.copy(p$1);\r\n\r\n\t\t\t\tata.applyToVector3(p$1);\r\n\t\t\t\tatb.sub(p$1);\r\n\r\n\t\t\t\tSingularValueDecomposition.solve(ata, atb, x);\r\n\t\t\t\terror = calculateError(ata, data.atb, x);\r\n\t\t\t\tx.add(massPoint);\r\n\r\n\t\t\t\tthis.hasSolution = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn error;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A data container for the QEF solver.\r\n\t */\r\n\r\n\tclass QEFData {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new QEF data container.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\t/**\r\n\t\t\t * A symmetric matrix.\r\n\t\t\t *\r\n\t\t\t * @type {SymmetricMatrix3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.ata = new SymmetricMatrix3();\r\n\r\n\t\t\tthis.ata.set(\r\n\r\n\t\t\t\t0, 0, 0,\r\n\t\t\t\t0, 0,\r\n\t\t\t\t0\r\n\r\n\t\t\t);\r\n\r\n\t\t\t/**\r\n\t\t\t * A vector.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.atb = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * An accumulation of the surface intersection points.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.massPointSum = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * The amount of accumulated surface intersection points.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.numPoints = 0;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the values of this data instance.\r\n\t\t *\r\n\t\t * @param {SymmetricMatrix3} ata - ATA.\r\n\t\t * @param {Vector3} atb - ATb.\r\n\t\t * @param {Vector3} massPointSum - The accumulated mass points.\r\n\t\t * @param {Vector3} numPoints - The number of mass points.\r\n\t\t * @return {QEFData} This data.\r\n\t\t */\r\n\r\n\t\tset(ata, atb, massPointSum, numPoints) {\r\n\r\n\t\t\tthis.ata.copy(ata);\r\n\t\t\tthis.atb.copy(atb);\r\n\r\n\t\t\tthis.massPointSum.copy(massPointSum);\r\n\t\t\tthis.numPoints = numPoints;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Copies values from a given data instance.\r\n\t\t *\r\n\t\t * @param {QEFData} d - The data to copy.\r\n\t\t * @return {QEFData} This data.\r\n\t\t */\r\n\r\n\t\tcopy(d) {\r\n\r\n\t\t\treturn this.set(d.ata, d.atb, d.massPointSum, d.numPoints);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds the given surface intersection point and normal.\r\n\t\t *\r\n\t\t * @param {Vector3} p - An intersection point.\r\n\t\t * @param {Vector3} n - A surface intersection normal.\r\n\t\t */\r\n\r\n\t\tadd(p, n) {\r\n\r\n\t\t\tconst nx = n.x;\r\n\t\t\tconst ny = n.y;\r\n\t\t\tconst nz = n.z;\r\n\r\n\t\t\tconst b = p.dot(n);\r\n\r\n\t\t\tconst ata = this.ata.elements;\r\n\t\t\tconst atb = this.atb;\r\n\r\n\t\t\tata[0] += nx * nx;\r\n\t\t\tata[1] += nx * ny; ata[3] += ny * ny;\r\n\t\t\tata[2] += nx * nz; ata[4] += ny * nz; ata[5] += nz * nz;\r\n\r\n\t\t\tatb.x += b * nx;\r\n\t\t\tatb.y += b * ny;\r\n\t\t\tatb.z += b * nz;\r\n\r\n\t\t\tthis.massPointSum.add(p);\r\n\r\n\t\t\t++this.numPoints;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds an entire data set.\r\n\t\t *\r\n\t\t * @param {QEFData} d - QEF data.\r\n\t\t */\r\n\r\n\t\taddData(d) {\r\n\r\n\t\t\tthis.ata.add(d.ata);\r\n\t\t\tthis.atb.add(d.atb);\r\n\r\n\t\t\tthis.massPointSum.add(d.massPointSum);\r\n\t\t\tthis.numPoints += d.numPoints;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this data.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.ata.set(\r\n\r\n\t\t\t\t0, 0, 0,\r\n\t\t\t\t0, 0,\r\n\t\t\t\t0\r\n\r\n\t\t\t);\r\n\r\n\t\t\tthis.atb.set(0, 0, 0);\r\n\t\t\tthis.massPointSum.set(0, 0, 0);\r\n\t\t\tthis.numPoints = 0;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clones this data.\r\n\t\t *\r\n\t\t * @return {QEFData} The cloned data.\r\n\t\t */\r\n\r\n\t\tclone() {\r\n\r\n\t\t\treturn new this.constructor().copy(this);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Mathematical system components.\r\n\t *\r\n\t * @module rabbit-hole/math\r\n\t */\n\n\t/**\r\n\t * An isovalue bias for the Zero Crossing approximation.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst ISOVALUE_BIAS = 1e-4;\r\n\r\n\t/**\r\n\t * An error threshold for the Zero Crossing approximation.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst INTERVAL_THRESHOLD = 1e-6;\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst ab = new Vector3();\r\n\r\n\t/**\r\n\t * A point.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst p$2 = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst v$6 = new Vector3();\r\n\r\n\t/**\r\n\t * An edge between two material grid points.\r\n\t */\r\n\r\n\tclass Edge {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new edge.\r\n\t\t *\r\n\t\t * @param {Vector3} [a] - A starting point. If none is provided, a new vector will be cretaed.\r\n\t\t * @param {Vector3} [b] - An ending point. If none is provided, a new vector will be cretaed.\r\n\t\t */\r\n\r\n\t\tconstructor(a = new Vector3(), b = new Vector3()) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The starting point of the edge.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.a = a;\r\n\r\n\t\t\t/**\r\n\t\t\t * The ending point of the edge.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.b = b;\r\n\r\n\t\t\t/**\r\n\t\t\t * The index of the starting material grid point.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.index = -1;\r\n\r\n\t\t\t/**\r\n\t\t\t * The local grid coordinates of the starting point.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.coordinates = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * The Zero Crossing interpolation value.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.t = 0.0;\r\n\r\n\t\t\t/**\r\n\t\t\t * The surface normal at the Zero Crossing position.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.n = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Approximates the smallest density along the edge.\r\n\t\t *\r\n\t\t * @param {SignedDistanceFunction} sdf - A density field.\r\n\t\t * @param {Number} [steps=8] - The maximum number of interpolation steps. Cannot be smaller than 2.\r\n\t\t */\r\n\r\n\t\tapproximateZeroCrossing(sdf, steps = 8) {\r\n\r\n\t\t\tconst s = Math.max(1, steps - 1);\r\n\r\n\t\t\tlet a = 0.0;\r\n\t\t\tlet b = 1.0;\r\n\t\t\tlet c = 0.0;\r\n\t\t\tlet i = 0;\r\n\r\n\t\t\tlet densityA, densityC;\r\n\r\n\t\t\t// Compute the vector from a to b.\r\n\t\t\tab.subVectors(this.b, this.a);\r\n\r\n\t\t\t// Use bisection to find the root of the SDF.\r\n\t\t\twhile(i <= s) {\r\n\r\n\t\t\t\tc = (a + b) / 2;\r\n\r\n\t\t\t\tp$2.addVectors(this.a, v$6.copy(ab).multiplyScalar(c));\r\n\t\t\t\tdensityC = sdf.sample(p$2);\r\n\r\n\t\t\t\tif(Math.abs(densityC) <= ISOVALUE_BIAS || (b - a) / 2 <= INTERVAL_THRESHOLD) {\r\n\r\n\t\t\t\t\t// Solution found.\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tp$2.addVectors(this.a, v$6.copy(ab).multiplyScalar(a));\r\n\t\t\t\t\tdensityA = sdf.sample(p$2);\r\n\r\n\t\t\t\t\tif(Math.sign(densityC) === Math.sign(densityA)) {\r\n\r\n\t\t\t\t\t\ta = c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tb = c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t++i;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.t = c;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the Zero Crossing position.\r\n\t\t *\r\n\t\t * @param {Vector3} target - A target for the Zero Crossing position. If none is provided, a new vector will be created.\r\n\t\t * @return {Vector3} The Zero Crossing position.\r\n\t\t */\r\n\r\n\t\tcomputeZeroCrossingPosition(target = new Vector3()) {\r\n\r\n\t\t\treturn target.subVectors(this.b, this.a).multiplyScalar(this.t).add(this.a);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Computes the normal of the surface at the edge intersection.\r\n\t\t *\r\n\t\t * @param {SignedDistanceFunction} sdf - A density field.\r\n\t\t * @return {Vector3} The normal.\r\n\t\t * @todo Use analytical derivation instead of finite differences.\r\n\t\t */\r\n\r\n\t\tcomputeSurfaceNormal(sdf) {\r\n\r\n\t\t\tconst position = this.computeZeroCrossingPosition(ab);\r\n\t\t\tconst E = 1e-3;\r\n\r\n\t\t\tconst dx = sdf.sample(p$2.addVectors(position, v$6.set(E, 0, 0))) - sdf.sample(p$2.subVectors(position, v$6.set(E, 0, 0)));\r\n\t\t\tconst dy = sdf.sample(p$2.addVectors(position, v$6.set(0, E, 0))) - sdf.sample(p$2.subVectors(position, v$6.set(0, E, 0)));\r\n\t\t\tconst dz = sdf.sample(p$2.addVectors(position, v$6.set(0, 0, E))) - sdf.sample(p$2.subVectors(position, v$6.set(0, 0, E)));\r\n\r\n\t\t\tthis.n.set(dx, dy, dz).normalize();\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * An edge.\r\n\t *\r\n\t * @type {Edge}\r\n\t * @private\r\n\t */\r\n\r\n\tconst edge = new Edge();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst offsetA = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst offsetB = new Vector3();\r\n\r\n\t/**\r\n\t * An edge iterator.\r\n\t *\r\n\t * @implements {Iterator}\r\n\t * @implements {Iterable}\r\n\t */\r\n\r\n\tclass EdgeIterator {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new edge iterator.\r\n\t\t *\r\n\t\t * @param {EdgeData} edgeData - A set of edge data.\r\n\t\t * @param {Vector3} cellPosition - The position of the data cell.\r\n\t\t * @param {Number} cellSize - The size of the data cell.\r\n\t\t * @param {Number} [c=0] - The dimension index to start at.\r\n\t\t * @param {Number} [d=3] - The dimension limit.\r\n\t\t */\r\n\r\n\t\tconstructor(edgeData, cellPosition, cellSize, c = 0, d = 3) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The edge data.\r\n\t\t\t *\r\n\t\t\t * @type {EdgeData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.edgeData = edgeData;\r\n\r\n\t\t\t/**\r\n\t\t\t * The data cell position.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.cellPosition = cellPosition;\r\n\r\n\t\t\t/**\r\n\t\t\t * The data cell size.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.cellSize = cellSize;\r\n\r\n\t\t\t/**\r\n\t\t\t * The edges.\r\n\t\t\t *\r\n\t\t\t * @type {Uint32Array[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.indices = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * The Zero Crossings.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.zeroCrossings = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * The intersection normals.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.normals = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * The axes of the existing edges.\r\n\t\t\t *\r\n\t\t\t * @type {Uint8Array[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.axes = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * The amount of edges for each internal set of edges (X -> Y -> Z).\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.lengths = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * An iterator result.\r\n\t\t\t *\r\n\t\t\t * @type {IteratorResult}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.result = new IteratorResult();\r\n\r\n\t\t\t/**\r\n\t\t\t * The initial dimension index.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.initialC = c;\r\n\r\n\t\t\t/**\r\n\t\t\t * The current dimension index.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.c = c;\r\n\r\n\t\t\t/**\r\n\t\t\t * The initial dimension limit.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.initialD = d;\r\n\r\n\t\t\t/**\r\n\t\t\t * The dimension limit.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.d = d;\r\n\r\n\t\t\t/**\r\n\t\t\t * The current iteration index.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.i = 0;\r\n\r\n\t\t\t/**\r\n\t\t\t * The current iteration limit.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.l = 0;\r\n\r\n\t\t\tthis.reset();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Resets this iterator.\r\n\t\t *\r\n\t\t * @return {EdgeIterator} This iterator.\r\n\t\t */\r\n\r\n\t\treset() {\r\n\r\n\t\t\tconst edgeData = this.edgeData;\r\n\t\t\tconst indices = [];\r\n\t\t\tconst zeroCrossings = [];\r\n\t\t\tconst normals = [];\r\n\t\t\tconst axes = [];\r\n\t\t\tconst lengths = [];\r\n\r\n\t\t\tlet a, c, d, l;\r\n\r\n\t\t\tthis.i = 0;\r\n\t\t\tthis.c = 0;\r\n\t\t\tthis.d = 0;\r\n\r\n\t\t\t// Create a collection of edges without empty arrays.\r\n\t\t\tfor(c = this.initialC, a = 4 >> c, d = this.initialD; c < d; ++c, a >>= 1) {\r\n\r\n\t\t\t\tl = edgeData.indices[c].length;\r\n\r\n\t\t\t\tif(l > 0) {\r\n\r\n\t\t\t\t\tindices.push(edgeData.indices[c]);\r\n\t\t\t\t\tzeroCrossings.push(edgeData.zeroCrossings[c]);\r\n\t\t\t\t\tnormals.push(edgeData.normals[c]);\r\n\t\t\t\t\taxes.push(pattern[a]);\r\n\t\t\t\t\tlengths.push(l);\r\n\r\n\t\t\t\t\t++this.d;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.l = (lengths.length > 0) ? lengths[0] : 0;\r\n\r\n\t\t\tthis.indices = indices;\r\n\t\t\tthis.zeroCrossings = zeroCrossings;\r\n\t\t\tthis.normals = normals;\r\n\t\t\tthis.axes = axes;\r\n\t\t\tthis.lengths = lengths;\r\n\r\n\t\t\tthis.result.reset();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Iterates over the edges.\r\n\t\t *\r\n\t\t * @return {IteratorResult} The next edge.\r\n\t\t */\r\n\r\n\t\tnext() {\r\n\r\n\t\t\tconst s = this.cellSize;\r\n\t\t\tconst n = HermiteData.resolution;\r\n\t\t\tconst m = n + 1;\r\n\t\t\tconst mm = m * m;\r\n\r\n\t\t\tconst result = this.result;\r\n\t\t\tconst base = this.cellPosition;\r\n\r\n\t\t\tlet axis, index;\r\n\t\t\tlet x, y, z;\r\n\t\t\tlet c, i;\r\n\r\n\t\t\t// Has the end been reached?\r\n\t\t\tif(this.i === this.l) {\r\n\r\n\t\t\t\t// Move on to the next set of edges (X -> Y -> Z).\r\n\t\t\t\tthis.l = (++this.c < this.d) ? this.lengths[this.c] : 0;\r\n\t\t\t\tthis.i = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Are there any edges left?\r\n\t\t\tif(this.i < this.l) {\r\n\r\n\t\t\t\tc = this.c;\r\n\t\t\t\ti = this.i;\r\n\r\n\t\t\t\taxis = this.axes[c];\r\n\r\n\t\t\t\t// Each edge is uniquely described by its starting grid point index.\r\n\t\t\t\tindex = this.indices[c][i];\r\n\t\t\t\tedge.index = index;\r\n\r\n\t\t\t\t// Calculate the local grid coordinates from the one-dimensional index.\r\n\t\t\t\tx = index % m;\r\n\t\t\t\ty = Math.trunc((index % mm) / m);\r\n\t\t\t\tz = Math.trunc(index / mm);\r\n\r\n\t\t\t\tedge.coordinates.set(x, y, z);\r\n\r\n\t\t\t\toffsetA.set(\r\n\t\t\t\t\tx * s / n,\r\n\t\t\t\t\ty * s / n,\r\n\t\t\t\t\tz * s / n\r\n\t\t\t\t);\r\n\r\n\t\t\t\toffsetB.set(\r\n\t\t\t\t\t(x + axis[0]) * s / n,\r\n\t\t\t\t\t(y + axis[1]) * s / n,\r\n\t\t\t\t\t(z + axis[2]) * s / n\r\n\t\t\t\t);\r\n\r\n\t\t\t\tedge.a.addVectors(base, offsetA);\r\n\t\t\t\tedge.b.addVectors(base, offsetB);\r\n\r\n\t\t\t\tedge.t = this.zeroCrossings[c][i];\r\n\t\t\t\tedge.n.fromArray(this.normals[c], i * 3);\r\n\r\n\t\t\t\tresult.value = edge;\r\n\r\n\t\t\t\t++this.i;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// There are no more edges left.\r\n\t\t\t\tresult.value = null;\r\n\t\t\t\tresult.done = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Called when this iterator will no longer be run to completion.\r\n\t\t *\r\n\t\t * @param {Object} value - An interator result value.\r\n\t\t * @return {IteratorResult} - A premature completion result.\r\n\t\t */\r\n\r\n\t\treturn(value) {\r\n\r\n\t\t\tthis.result.value = value;\r\n\t\t\tthis.result.done = true;\r\n\r\n\t\t\treturn this.result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns this iterator.\r\n\t\t *\r\n\t\t * @return {EdteIterator} An iterator.\r\n\t\t */\r\n\r\n\t\t[Symbol.iterator]() {\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Stores edge data separately for each dimension.\r\n\t *\r\n\t * With a grid resolution N, there are `3 * (N + 1) * N` edges in total, but\r\n\t * the number of edges that actually contain the volume's surface is usually\r\n\t * much lower.\r\n\t *\r\n\t * @implements {Serializable}\r\n\t * @implements {Deserializable}\r\n\t * @implements {TransferableContainer}\r\n\t */\r\n\r\n\tclass EdgeData {\r\n\r\n\t\t/**\r\n\t\t * Constructs new edge data.\r\n\t\t *\r\n\t\t * @param {Number} [x=0] - The amount of edges along the X-axis. If <= 0, no memory will be allocated.\r\n\t\t * @param {Number} [y=x] - The amount of edges along the Y-axis. If omitted, this will be the same as x.\r\n\t\t * @param {Number} [z=x] - The amount of edges along the Z-axis. If omitted, this will be the same as x.\r\n\t\t */\r\n\r\n\t\tconstructor(x = 0, y = x, z = x) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The edges.\r\n\t\t\t *\r\n\t\t\t * Edges are stored as starting grid point indices in ascending order. The\r\n\t\t\t * ending point indices are implicitly defined through the dimension split:\r\n\t\t\t *\r\n\t\t\t * Given a starting point index A, the ending point index B for the X-, Y-\r\n\t\t\t * and Z-axis is defined as `A + 1`, `A + N` and `A + N` respectively where\r\n\t\t\t * N is the grid resolution + 1.\r\n\t\t\t *\r\n\t\t\t * @type {Uint32Array[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.indices = (x <= 0) ? null : [\r\n\t\t\t\tnew Uint32Array(x),\r\n\t\t\t\tnew Uint32Array(y),\r\n\t\t\t\tnew Uint32Array(z)\r\n\t\t\t];\r\n\r\n\t\t\t/**\r\n\t\t\t * The Zero Crossing interpolation values.\r\n\t\t\t *\r\n\t\t\t * Each value describes the relative surface intersection position on the\r\n\t\t\t * respective edge. The values correspond to the order of the edges.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.zeroCrossings = (x <= 0) ? null : [\r\n\t\t\t\tnew Float32Array(x),\r\n\t\t\t\tnew Float32Array(y),\r\n\t\t\t\tnew Float32Array(z)\r\n\t\t\t];\r\n\r\n\t\t\t/**\r\n\t\t\t * The surface intersection normals.\r\n\t\t\t *\r\n\t\t\t * The vectors are stored as [x, y, z] float triples and correspond to the\r\n\t\t\t * order of the edges.\r\n\t\t\t *\r\n\t\t\t * @type {Float32Array[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.normals = (x <= 0) ? null : [\r\n\t\t\t\tnew Float32Array(x * 3),\r\n\t\t\t\tnew Float32Array(y * 3),\r\n\t\t\t\tnew Float32Array(z * 3)\r\n\t\t\t];\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Serialises this data.\r\n\t\t *\r\n\t\t * @param {Boolean} [deflate=false] - Whether the data should be compressed if possible.\r\n\t\t * @return {Object} The serialised data.\r\n\t\t */\r\n\r\n\t\tserialize(deflate = false) {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tedges: this.edges,\r\n\t\t\t\tzeroCrossings: this.zeroCrossings,\r\n\t\t\t\tnormals: this.normals\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the given serialised data.\r\n\t\t *\r\n\t\t * @param {Object} object - Serialised edge data. Can be null.\r\n\t\t * @return {Deserializable} This object or null if the given serialised data was null.\r\n\t\t */\r\n\r\n\t\tdeserialize(object) {\r\n\r\n\t\t\tlet result = this;\r\n\r\n\t\t\tif(object !== null) {\r\n\r\n\t\t\t\tthis.edges = object.edges;\r\n\t\t\t\tthis.zeroCrossings = object.zeroCrossings;\r\n\t\t\t\tthis.normals = object.normals;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a list of transferable items.\r\n\t\t *\r\n\t\t * @param {Array} [transferList] - An optional target list. The transferable items will be added to this list.\r\n\t\t * @return {Transferable[]} The transfer list.\r\n\t\t */\r\n\r\n\t\tcreateTransferList(transferList = []) {\r\n\r\n\t\t\tconst arrays = [\r\n\r\n\t\t\t\tthis.edges[0],\r\n\t\t\t\tthis.edges[1],\r\n\t\t\t\tthis.edges[2],\r\n\r\n\t\t\t\tthis.zeroCrossings[0],\r\n\t\t\t\tthis.zeroCrossings[1],\r\n\t\t\t\tthis.zeroCrossings[2],\r\n\r\n\t\t\t\tthis.normals[0],\r\n\t\t\t\tthis.normals[1],\r\n\t\t\t\tthis.normals[2]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tlet array;\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 0, l = arrays.length; i < l; ++i) {\r\n\r\n\t\t\t\tarray = arrays[i];\r\n\r\n\t\t\t\tif(array !== null) {\r\n\r\n\t\t\t\t\ttransferList.push(array.buffer);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn transferList;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns a new edge iterator.\r\n\t\t *\r\n\t\t * @param {Vector3} cellPosition - The position of the volume data cell.\r\n\t\t * @param {Number} cellSize - The size of the volume data cell.\r\n\t\t * @return {EdgeIterator} An iterator.\r\n\t\t */\r\n\r\n\t\tedges(cellPosition, cellSize) {\r\n\r\n\t\t\treturn new EdgeIterator(this, cellPosition, cellSize);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a new edge iterator that only returns edges along the X-axis.\r\n\t\t *\r\n\t\t * @param {Vector3} cellPosition - The position of the volume data cell.\r\n\t\t * @param {Number} cellSize - The size of the volume data cell.\r\n\t\t * @return {EdgeIterator} An iterator.\r\n\t\t */\r\n\r\n\t\tedgesX(cellPosition, cellSize) {\r\n\r\n\t\t\treturn new EdgeIterator(this, cellPosition, cellSize, 0, 1);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a new edge iterator that only returns edges along the Y-axis.\r\n\t\t *\r\n\t\t * @param {Vector3} cellPosition - The position of the volume data cell.\r\n\t\t * @param {Number} cellSize - The size of the volume data cell.\r\n\t\t * @return {EdgeIterator} An iterator.\r\n\t\t */\r\n\r\n\t\tedgesY(cellPosition, cellSize) {\r\n\r\n\t\t\treturn new EdgeIterator(this, cellPosition, cellSize, 1, 2);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a new edge iterator that only returns edges along the Z-axis.\r\n\t\t *\r\n\t\t * @param {Vector3} cellPosition - The position of the volume data cell.\r\n\t\t * @param {Number} cellSize - The size of the volume data cell.\r\n\t\t * @return {EdgeIterator} An iterator.\r\n\t\t */\r\n\r\n\t\tedgesZ(cellPosition, cellSize) {\r\n\r\n\t\t\treturn new EdgeIterator(this, cellPosition, cellSize, 2, 3);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the amount of edges for one axis based on a given resolution.\r\n\t\t *\r\n\t\t * @param {Number} n - The grid resolution.\r\n\t\t * @return {Number} The amount of edges for a single dimension.\r\n\t\t */\r\n\r\n\t\tstatic calculate1DEdgeCount(n) {\r\n\r\n\t\t\treturn Math.pow((n + 1), 2) * n;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * The material grid resolution.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tlet resolution = 0;\r\n\r\n\t/**\r\n\t * The total amount of grid point indices.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tlet indexCount = 0;\r\n\r\n\t/**\r\n\t * Rounds the given number up to the next power of two.\r\n\t *\r\n\t * @private\r\n\t * @param {Number} n - A number.\r\n\t * @return {Number} The next power of two.\r\n\t */\r\n\r\n\tfunction ceil2(n) {\r\n\r\n\t\treturn Math.pow(2, Math.max(0, Math.ceil(Math.log2(n))));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Hermite data.\r\n\t *\r\n\t * @implements {Serializable}\r\n\t * @implements {Deserializable}\r\n\t * @implements {TransferableContainer}\r\n\t */\r\n\r\n\tclass HermiteData {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new set of Hermite data.\r\n\t\t *\r\n\t\t * @param {Boolean} [initialise=true] - Whether the data should be initialised immediately.\r\n\t\t */\r\n\r\n\t\tconstructor(initialise = true) {\r\n\r\n\t\t\t/**\r\n\t\t\t * Describes how many material indices are currently solid:\r\n\t\t\t *\r\n\t\t\t * - The chunk lies outside the volume if there are no solid grid points.\r\n\t\t\t * - The chunk lies completely inside the volume if all points are solid.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.materials = 0;\r\n\r\n\t\t\t/**\r\n\t\t\t * The grid points.\r\n\t\t\t *\r\n\t\t\t * @type {Uint8Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.materialIndices = initialise ? new Uint8Array(indexCount) : null;\r\n\r\n\t\t\t/**\r\n\t\t\t * Run-length compression data.\r\n\t\t\t *\r\n\t\t\t * @type {Uint32Array}\r\n\t\t\t */\r\n\r\n\t\t\tthis.runLengths = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * The edge data.\r\n\t\t\t *\r\n\t\t\t * @type {EdgeData}\r\n\t\t\t */\r\n\r\n\t\t\tthis.edgeData = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Indicates whether this data container is empty.\r\n\t\t *\r\n\t\t * @type {Boolean}\r\n\t\t */\r\n\r\n\t\tget empty() {\r\n\r\n\t\t\treturn (this.materials === 0);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Indicates whether this data container is full.\r\n\t\t *\r\n\t\t * @type {Boolean}\r\n\t\t */\r\n\r\n\t\tget full() {\r\n\r\n\t\t\treturn (this.materials === indexCount);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Indicates whether this data is currently compressed.\r\n\t\t *\r\n\t\t * @type {Boolean}\r\n\t\t */\r\n\r\n\t\tget compressed() {\r\n\r\n\t\t\treturn (this.runLengths !== null);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Indicates whether this data is currently gone.\r\n\t\t *\r\n\t\t * @type {Boolean}\r\n\t\t */\r\n\r\n\t\tget neutered() {\r\n\r\n\t\t\treturn (!this.empty && this.materialIndices === null);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the given data.\r\n\t\t *\r\n\t\t * @param {HermiteData} data - The data to adopt.\r\n\t\t * @return {HermiteData} This data.\r\n\t\t */\r\n\r\n\t\tset(data) {\r\n\r\n\t\t\tthis.materials = data.materials;\r\n\t\t\tthis.materialIndices = data.materialIndices;\r\n\t\t\tthis.runLengths = data.runLengths;\r\n\t\t\tthis.edgeData = data.edgeData;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Removes all data.\r\n\t\t *\r\n\t\t * @return {HermiteData} This data.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.materials = 0;\r\n\t\t\tthis.materialIndices = null;\r\n\t\t\tthis.runLengths = null;\r\n\t\t\tthis.edgeData = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the specified material index.\r\n\t\t *\r\n\t\t * @param {Number} index - The index of the material index that should be updated.\r\n\t\t * @param {Number} value - The new material index.\r\n\t\t */\r\n\r\n\t\tsetMaterialIndex(index, value) {\r\n\r\n\t\t\t// Keep track of how many material indices are solid.\r\n\t\t\tif(this.materialIndices[index] === Material.AIR) {\r\n\r\n\t\t\t\tif(value !== Material.AIR) {\r\n\r\n\t\t\t\t\t++this.materials;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if(value === Material.AIR) {\r\n\r\n\t\t\t\t--this.materials;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.materialIndices[index] = value;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Compresses this data.\r\n\t\t *\r\n\t\t * @param {HermiteData} [target=this] - A target data set. The compressed data will be assigned to this set.\r\n\t\t * @return {HermiteData} The target data set.\r\n\t\t */\r\n\r\n\t\tcompress(target = this) {\r\n\r\n\t\t\tlet encoding;\r\n\r\n\t\t\tif(!this.compressed) {\r\n\r\n\t\t\t\t// Note: empty sets won't be compressed. They can be discarded.\r\n\t\t\t\tif(this.full) {\r\n\r\n\t\t\t\t\t// This deliberately destroys material variations to save space!\r\n\t\t\t\t\tencoding = new RunLengthEncoding(\r\n\t\t\t\t\t\t[this.materialIndices.length],\r\n\t\t\t\t\t\t[Material.SOLID]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tencoding = RunLengthEncoding.encode(this.materialIndices);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttarget.materialIndices = new Uint8Array(encoding.data);\r\n\t\t\t\ttarget.runLengths = new Uint32Array(encoding.runLengths);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttarget.materialIndices = this.materialIndices;\r\n\t\t\t\ttarget.runLengths = this.runLengths;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.materials = this.materials;\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Decompresses this data.\r\n\t\t *\r\n\t\t * @param {HermiteData} [target=this] - A target data set. If none is provided, the compressed data will be replaced with the decompressed data.\r\n\t\t * @return {HermiteData} The target data set.\r\n\t\t */\r\n\r\n\t\tdecompress(target = this) {\r\n\r\n\t\t\ttarget.materialIndices = !this.compressed ?\r\n\t\t\t\tthis.materialIndices : RunLengthEncoding.decode(\r\n\t\t\t\t\tthis.runLengths, this.materialIndices, new Uint8Array(indexCount)\r\n\t\t\t\t);\r\n\r\n\t\t\ttarget.runLengths = null;\r\n\t\t\ttarget.materials = this.materials;\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Serialises this data.\r\n\t\t *\r\n\t\t * @param {Boolean} [deflate=false] - Whether the data should be compressed if possible.\r\n\t\t * @return {Object} The serialised data.\r\n\t\t */\r\n\r\n\t\tserialize(deflate = false) {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tmaterials: this.materials,\r\n\t\t\t\tmaterialIndices: this.materialIndices,\r\n\t\t\t\trunLengths: this.runLengths,\r\n\t\t\t\tedgeData: (this.edgeData !== null) ? this.edgeData.serialize() : null\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adopts the given serialised data.\r\n\t\t *\r\n\t\t * @param {Object} object - Serialised Hermite data. Can be null.\r\n\t\t * @return {Deserializable} This object or null if the given serialised data was null.\r\n\t\t */\r\n\r\n\t\tdeserialize(object) {\r\n\r\n\t\t\tlet result = this;\r\n\r\n\t\t\tif(object !== null) {\r\n\r\n\t\t\t\tthis.materials = object.materials;\r\n\t\t\t\tthis.materialIndices = object.materialIndices;\r\n\t\t\t\tthis.runLengths = object.runLengths;\r\n\r\n\t\t\t\tif(object.edgeData !== null) {\r\n\r\n\t\t\t\t\tif(this.edgeData === null) {\r\n\r\n\t\t\t\t\t\t// Create an empty edge data container.\r\n\t\t\t\t\t\tthis.edgeData = new EdgeData();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.edgeData.deserialize(object.edgeData);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.edgeData = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a list of transferable items.\r\n\t\t *\r\n\t\t * @param {Array} [transferList] - An optional target list. The transferable items will be added to this list.\r\n\t\t * @return {Transferable[]} The transfer list.\r\n\t\t */\r\n\r\n\t\tcreateTransferList(transferList = []) {\r\n\r\n\t\t\tif(this.edgeData !== null) {\r\n\r\n\t\t\t\tthis.edgeData.createTransferList(transferList);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(this.materialIndices !== null) {\r\n\r\n\t\t\t\ttransferList.push(this.materialIndices.buffer);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(this.runLengths !== null) {\r\n\r\n\t\t\t\ttransferList.push(this.runLengths.buffer);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn transferList;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The material grid resolution.\r\n\t\t *\r\n\t\t * The effective resolution of a chunk of Hermite data is the distance between\r\n\t\t * two adjacent grid points with respect to the size of the containing world\r\n\t\t * octant.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tstatic get resolution() {\r\n\r\n\t\t\treturn resolution;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Warning: this value should only be set once.\r\n\t\t *\r\n\t\t * The upper limit is 256.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tstatic set resolution(value) {\r\n\r\n\t\t\tresolution = Math.max(1, Math.min(256, ceil2(value)));\r\n\t\t\tindexCount = Math.pow((resolution + 1), 3);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A cubic voxel that holds information about the surface of a volume.\r\n\t */\r\n\r\n\tclass Voxel {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new voxel.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\t/**\r\n\t\t\t * Holds binary material information about all eight corners of this voxel.\r\n\t\t\t *\r\n\t\t\t * A value of 0 means that this voxel is completely outside of the volume,\r\n\t\t\t * whereas a value of 255 means that it's fully inside of it. Any other\r\n\t\t\t * value indicates a material change which implies that the voxel contains\r\n\t\t\t * the surface.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.materials = 0;\r\n\r\n\t\t\t/**\r\n\t\t\t * The amount of edges that exhibit a material change in this voxel.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.edgeCount = 0;\r\n\r\n\t\t\t/**\r\n\t\t\t * A generated index for this voxel's vertex. Used during the construction\r\n\t\t\t * of the final polygons.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.index = -1;\r\n\r\n\t\t\t/**\r\n\t\t\t * The vertex that lies inside this voxel.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.position = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * The normal of the vertex that lies inside this voxel.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.normal = new Vector3();\r\n\r\n\t\t\t/**\r\n\t\t\t * A QEF data construct. Used to calculate the vertex position.\r\n\t\t\t *\r\n\t\t\t * @type {QEFData}\r\n\t\t\t */\r\n\r\n\t\t\tthis.qefData = null;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A QEF solver.\r\n\t *\r\n\t * @type {QEFSolver}\r\n\t * @private\r\n\t */\r\n\r\n\tconst qefSolver = new QEFSolver();\r\n\r\n\t/**\r\n\t * A bias for boundary checks.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst BIAS = 1e-1;\r\n\r\n\t/**\r\n\t * An error threshold for QEF-based voxel clustering.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tlet errorThreshold = -1;\r\n\r\n\t/**\r\n\t * A voxel octant.\r\n\t */\r\n\r\n\tclass VoxelCell extends CubicOctant {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new voxel octant.\r\n\t\t *\r\n\t\t * @param {Vector3} [min] - The lower bounds of the octant.\r\n\t\t * @param {Number} [size] - The size of the octant.\r\n\t\t */\r\n\r\n\t\tconstructor(min, size) {\r\n\r\n\t\t\tsuper(min, size);\r\n\r\n\t\t\t/**\r\n\t\t\t * A voxel that contains draw information.\r\n\t\t\t *\r\n\t\t\t * @type {Voxel}\r\n\t\t\t */\r\n\r\n\t\t\tthis.voxel = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Checks if the given point lies inside this cell.\r\n\t\t *\r\n\t\t * @param {Vector3} p - A point.\r\n\t\t * @return {Boolean} Whether the given point lies inside this cell.\r\n\t\t */\r\n\r\n\t\tcontains(p) {\r\n\r\n\t\t\tconst min = this.min;\r\n\t\t\tconst size = this.size;\r\n\r\n\t\t\treturn (\r\n\t\t\t\tp.x >= min.x - BIAS &&\r\n\t\t\t\tp.y >= min.y - BIAS &&\r\n\t\t\t\tp.z >= min.z - BIAS &&\r\n\t\t\t\tp.x <= min.x + size + BIAS &&\r\n\t\t\t\tp.y <= min.y + size + BIAS &&\r\n\t\t\t\tp.z <= min.z + size + BIAS\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Attempts to simplify this cell.\r\n\t\t *\r\n\t\t * @return {Number} The amount of removed voxels.\r\n\t\t */\r\n\r\n\t\tcollapse() {\r\n\r\n\t\t\tconst children = this.children;\r\n\r\n\t\t\tconst signs = [\r\n\t\t\t\t-1, -1, -1, -1,\r\n\t\t\t\t-1, -1, -1, -1\r\n\t\t\t];\r\n\r\n\t\t\tconst position = new Vector3();\r\n\r\n\t\t\tlet midSign = -1;\r\n\t\t\tlet collapsible = (children !== null);\r\n\r\n\t\t\tlet removedVoxels = 0;\r\n\r\n\t\t\tlet child, sign, voxel;\r\n\t\t\tlet qefData, error;\r\n\r\n\t\t\tlet v, i;\r\n\r\n\t\t\tif(collapsible) {\r\n\r\n\t\t\t\tqefData = new QEFData();\r\n\r\n\t\t\t\tfor(v = 0, i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\t\tchild = children[i];\r\n\t\t\t\t\tremovedVoxels += child.collapse();\r\n\t\t\t\t\tvoxel = child.voxel;\r\n\r\n\t\t\t\t\tif(child.children !== null) {\r\n\r\n\t\t\t\t\t\t// Couldn't simplify the child.\r\n\t\t\t\t\t\tcollapsible = false;\r\n\r\n\t\t\t\t\t} else if(voxel !== null) {\r\n\r\n\t\t\t\t\t\tqefData.addData(voxel.qefData);\r\n\r\n\t\t\t\t\t\tmidSign = (voxel.materials >> (7 - i)) & 1;\r\n\t\t\t\t\t\tsigns[i] = (voxel.materials >> i) & 1;\r\n\r\n\t\t\t\t\t\t++v;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(collapsible) {\r\n\r\n\t\t\t\t\terror = qefSolver.setData(qefData).solve(position);\r\n\r\n\t\t\t\t\tif(error <= errorThreshold) {\r\n\r\n\t\t\t\t\t\tvoxel = new Voxel();\r\n\t\t\t\t\t\tvoxel.position.copy(this.contains(position) ? position : qefSolver.massPoint);\r\n\r\n\t\t\t\t\t\tfor(i = 0; i < 8; ++i) {\r\n\r\n\t\t\t\t\t\t\tsign = signs[i];\r\n\t\t\t\t\t\t\tchild = children[i];\r\n\r\n\t\t\t\t\t\t\tif(sign === -1) {\r\n\r\n\t\t\t\t\t\t\t\t// Undetermined, use mid sign instead.\r\n\t\t\t\t\t\t\t\tvoxel.materials |= (midSign << i);\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tvoxel.materials |= (sign << i);\r\n\r\n\t\t\t\t\t\t\t\t// Accumulate normals.\r\n\t\t\t\t\t\t\t\tvoxel.normal.add(child.voxel.normal);\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvoxel.normal.normalize();\r\n\t\t\t\t\t\tvoxel.qefData = qefData;\r\n\r\n\t\t\t\t\t\tthis.voxel = voxel;\r\n\t\t\t\t\t\tthis.children = null;\r\n\r\n\t\t\t\t\t\t// Removed existing voxels and created a new one.\r\n\t\t\t\t\t\tremovedVoxels += v - 1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn removedVoxels;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * An error threshold for QEF-based voxel clustering (mesh simplification).\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tstatic get errorThreshold() {\r\n\r\n\t\t\treturn errorThreshold;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The mesh simplification error threshold.\r\n\t\t *\r\n\t\t * A bigger threshold allows more voxel cells to collapse which results in\r\n\t\t * less vertices being created.\r\n\t\t *\r\n\t\t * An error threshold of -1 disables the mesh simplification.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tstatic set errorThreshold(value) {\r\n\r\n\t\t\terrorThreshold = value;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Creates intermediate voxel cells down to the leaf octant that is described\r\n\t * by the given local grid coordinates and returns it.\r\n\t *\r\n\t * @private\r\n\t * @param {VoxelCell} cell - The root octant.\r\n\t * @param {Number} n - The grid resolution.\r\n\t * @param {Number} x - A local grid point X-coordinate.\r\n\t * @param {Number} y - A local grid point Y-coordinate.\r\n\t * @param {Number} z - A local grid point Z-coordinate.\r\n\t * @return {VoxelCell} A leaf voxel cell.\r\n\t */\r\n\r\n\tfunction getCell(cell, n, x, y, z) {\r\n\r\n\t\tlet i = 0;\r\n\r\n\t\tfor(n = n >> 1; n > 0; n >>= 1, i = 0) {\r\n\r\n\t\t\t// YZ.\r\n\t\t\tif(x >= n) {\r\n\r\n\t\t\t\ti += 4; x -= n;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// XZ.\r\n\t\t\tif(y >= n) {\r\n\r\n\t\t\t\ti += 2; y -= n;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// XY.\r\n\t\t\tif(z >= n) {\r\n\r\n\t\t\t\ti += 1; z -= n;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(cell.children === null) {\r\n\r\n\t\t\t\tcell.split();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcell = cell.children[i];\r\n\r\n\t\t}\r\n\r\n\t\treturn cell;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a voxel and builds a material configuration code from the materials\r\n\t * in the voxel corners.\r\n\t *\r\n\t * @private\r\n\t * @param {Number} n - The grid resolution.\r\n\t * @param {Number} x - A local grid point X-coordinate.\r\n\t * @param {Number} y - A local grid point Y-coordinate.\r\n\t * @param {Number} z - A local grid point Z-coordinate.\r\n\t * @param {Uint8Array} materialIndices - The material indices.\r\n\t * @return {Voxel} A voxel.\r\n\t */\r\n\r\n\tfunction createVoxel(n, x, y, z, materialIndices) {\r\n\r\n\t\tconst m = n + 1;\r\n\t\tconst mm = m * m;\r\n\r\n\t\tconst voxel = new Voxel();\r\n\r\n\t\tlet materials, edgeCount;\r\n\t\tlet material, offset, index;\r\n\t\tlet c1, c2, m1, m2;\r\n\r\n\t\tlet i;\r\n\r\n\t\t// Pack the material information of the eight corners into a single byte.\r\n\t\tfor(materials = 0, i = 0; i < 8; ++i) {\r\n\r\n\t\t\t// Translate the coordinates into a one-dimensional grid point index.\r\n\t\t\toffset = pattern[i];\r\n\t\t\tindex = (z + offset[2]) * mm + (y + offset[1]) * m + (x + offset[0]);\r\n\r\n\t\t\t// Convert the identified material index into a binary value.\r\n\t\t\tmaterial = Math.min(materialIndices[index], Material.SOLID);\r\n\r\n\t\t\t// Store the value in bit i.\r\n\t\t\tmaterials |= (material << i);\r\n\r\n\t\t}\r\n\r\n\t\t// Find out how many edges intersect with the implicit surface.\r\n\t\tfor(edgeCount = 0, i = 0; i < 12; ++i) {\r\n\r\n\t\t\tc1 = edges[i][0];\r\n\t\t\tc2 = edges[i][1];\r\n\r\n\t\t\tm1 = (materials >> c1) & 1;\r\n\t\t\tm2 = (materials >> c2) & 1;\r\n\r\n\t\t\t// Check if there is a material change on the edge.\r\n\t\t\tif(m1 !== m2) {\r\n\r\n\t\t\t\t++edgeCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvoxel.materials = materials;\r\n\t\tvoxel.edgeCount = edgeCount;\r\n\t\tvoxel.qefData = new QEFData();\r\n\r\n\t\treturn voxel;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A sparse, cubic voxel octree.\r\n\t */\r\n\r\n\tclass SparseVoxelOctree extends Octree {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new voxel octree.\r\n\t\t *\r\n\t\t * @param {HermiteData} data - A set of volume data.\r\n\t\t * @param {Vector3} [min] - The lower bounds of this octree.\r\n\t\t * @param {Number} [size=1] - The size of this octree.\r\n\t\t */\r\n\r\n\t\tconstructor(data, min = new Vector3(), size = 1) {\r\n\r\n\t\t\tsuper();\r\n\r\n\t\t\t/**\r\n\t\t\t * The root octant.\r\n\t\t\t *\r\n\t\t\t * @type {VoxelCell}\r\n\t\t\t */\r\n\r\n\t\t\tthis.root = new VoxelCell(min, size);\r\n\r\n\t\t\t/**\r\n\t\t\t * The amount of voxels in this octree.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t */\r\n\r\n\t\t\tthis.voxelCount = 0;\r\n\r\n\t\t\tif(data !== null && data.edgeData !== null) {\r\n\r\n\t\t\t\tthis.construct(data);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(VoxelCell.errorThreshold >= 0) {\r\n\r\n\t\t\t\tthis.simplify();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Attempts to simplify the octree by clustering voxels.\r\n\t\t *\r\n\t\t * @private\r\n\t\t */\r\n\r\n\t\tsimplify() {\r\n\r\n\t\t\tthis.voxelCount -= this.root.collapse();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Constructs voxel cells from volume data.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {HermiteData} data - The volume data.\r\n\t\t */\r\n\r\n\t\tconstruct(data) {\r\n\r\n\t\t\tconst n = HermiteData.resolution;\r\n\t\t\tconst edgeData = data.edgeData;\r\n\t\t\tconst materialIndices = data.materialIndices;\r\n\r\n\t\t\tconst qefSolver = new QEFSolver();\r\n\t\t\tconst intersection = new Vector3();\r\n\r\n\t\t\tconst edgeIterators = [\r\n\t\t\t\tedgeData.edgesX(this.min, this.root.size),\r\n\t\t\t\tedgeData.edgesY(this.min, this.root.size),\r\n\t\t\t\tedgeData.edgesZ(this.min, this.root.size)\r\n\t\t\t];\r\n\r\n\t\t\tconst sequences = [\r\n\t\t\t\tnew Uint8Array([0, 1, 2, 3]),\r\n\t\t\t\tnew Uint8Array([0, 1, 4, 5]),\r\n\t\t\t\tnew Uint8Array([0, 2, 4, 6])\r\n\t\t\t];\r\n\r\n\t\t\tlet voxelCount = 0;\r\n\r\n\t\t\tlet edges, edge;\r\n\t\t\tlet sequence, offset;\r\n\t\t\tlet cell, voxel;\r\n\r\n\t\t\tlet x, y, z;\r\n\t\t\tlet d, i;\r\n\r\n\t\t\t// Process edges X -> Y -> Z.\r\n\t\t\tfor(d = 0; d < 3; ++d) {\r\n\r\n\t\t\t\tsequence = sequences[d];\r\n\t\t\t\tedges = edgeIterators[d];\r\n\r\n\t\t\t\tfor(edge of edges) {\r\n\r\n\t\t\t\t\tedge.computeZeroCrossingPosition(intersection);\r\n\r\n\t\t\t\t\t// Each edge can belong to up to four voxel cells.\r\n\t\t\t\t\tfor(i = 0; i < 4; ++i) {\r\n\r\n\t\t\t\t\t\t// Rotate around the edge.\r\n\t\t\t\t\t\toffset = pattern[sequence[i]];\r\n\r\n\t\t\t\t\t\tx = edge.coordinates.x - offset[0];\r\n\t\t\t\t\t\ty = edge.coordinates.y - offset[1];\r\n\t\t\t\t\t\tz = edge.coordinates.z - offset[2];\r\n\r\n\t\t\t\t\t\t// Check if the adjusted coordinates still lie inside the grid bounds.\r\n\t\t\t\t\t\tif(x >= 0 && y >= 0 && z >= 0 && x < n && y < n && z < n) {\r\n\r\n\t\t\t\t\t\t\tcell = getCell(this.root, n, x, y, z);\r\n\r\n\t\t\t\t\t\t\tif(cell.voxel === null) {\r\n\r\n\t\t\t\t\t\t\t\t// The existence of the edge guarantees that the voxel contains the surface.\r\n\t\t\t\t\t\t\t\tcell.voxel = createVoxel(n, x, y, z, materialIndices);\r\n\r\n\t\t\t\t\t\t\t\t++voxelCount;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Add the edge data to the voxel.\r\n\t\t\t\t\t\t\tvoxel = cell.voxel;\r\n\t\t\t\t\t\t\tvoxel.normal.add(edge.n);\r\n\t\t\t\t\t\t\tvoxel.qefData.add(intersection, edge.n);\r\n\r\n\t\t\t\t\t\t\tif(voxel.qefData.numPoints === voxel.edgeCount) {\r\n\r\n\t\t\t\t\t\t\t\t// Finalise the voxel by solving the accumulated data.\r\n\t\t\t\t\t\t\t\tqefSolver.setData(voxel.qefData).solve(voxel.position);\r\n\r\n\t\t\t\t\t\t\t\tif(!cell.contains(voxel.position)) {\r\n\r\n\t\t\t\t\t\t\t\t\tvoxel.position.copy(qefSolver.massPoint);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tvoxel.normal.normalize();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.voxelCount = voxelCount;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * Space partitioning components used for contouring.\r\n\t *\r\n\t * @module rabbit-hole/octree/voxel\r\n\t */\n\n\t/**\r\n\t * A FIFO queue.\r\n\t *\r\n\t * Elements are added to the end of the queue and removed from the front.\r\n\t *\r\n\t * Based on:\r\n\t *  http://code.stephenmorley.org/javascript/queues/\r\n\t */\n\n\t/**\r\n\t * A world octant.\r\n\t *\r\n\t * This octant serves as a volume data container. Its position is implicitly\r\n\t * defined by its key while its size is defined by the LOD grid in which it\r\n\t * resides. Additionally, it can store a queue of pending CSG operations.\r\n\t */\n\n\t/**\r\n\t * A world octant that doesn't reside in LOD zero.\r\n\t *\r\n\t * This octant is a container for resampled volume data. Additionally, it stores\r\n\t * information about the existence of its potential children.\r\n\t */\n\n\t/**\r\n\t * A collection of binary number utilities.\r\n\t */\n\n\t/**\r\n\t * A key range iterator.\r\n\t *\r\n\t * @implements {Iterator}\r\n\t * @implements {Iterable}\r\n\t */\n\n\t/**\r\n\t * A design for octant keys.\r\n\t *\r\n\t * 3D coordinates are packed into a single integer to obtain a unique key. This\r\n\t * class describes the bit allotment for each coordinate and provides methods\r\n\t * for key packing and unpacking.\r\n\t *\r\n\t * See {@link KeyDesign.BITS} for the total amount of available bits.\r\n\t */\n\n\t/**\r\n\t * A world octant ID.\r\n\t *\r\n\t * Each octant can be identified with a unique positional key and a LOD value.\r\n\t */\n\n\t/**\r\n\t * A world octant wrapper that stores positional information.\r\n\t */\n\n\t/**\r\n\t * A world octant iterator.\r\n\t *\r\n\t * @implements {Iterator}\r\n\t * @implements {Iterable}\r\n\t */\n\n\t/**\r\n\t * An enumeration of CSG operation types.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {String} UNION - Indicates a union of volume data.\r\n\t * @property {String} DIFFERENCE - Indicates a subtraction of volume data.\r\n\t * @property {String} INTERSECTION - Indicates an intersection of volume data.\r\n\t * @property {String} DENSITY_FUNCTION - Indicates volume data generation.\r\n\t */\r\n\r\n\tconst OperationType = {\r\n\r\n\t\tUNION: \"csg.union\",\r\n\t\tDIFFERENCE: \"csg.difference\",\r\n\t\tINTERSECTION: \"csg.intersection\",\r\n\t\tDENSITY_FUNCTION: \"csg.densityfunction\"\r\n\r\n\t};\n\n\t/**\r\n\t * A point.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst p$3 = new Vector3();\r\n\r\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst v$8 = new Vector3();\r\n\r\n\t/**\r\n\t * A box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b0 = new Box3();\r\n\r\n\t/**\r\n\t * A box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b1 = new Box3();\r\n\r\n\t/**\r\n\t * A box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b2 = new Box3();\r\n\r\n\t/**\r\n\t * A world octree CSG operation manager.\r\n\t */\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst v$9 = new Vector3();\r\n\r\n\t/**\r\n\t * A line.\r\n\t *\r\n\t * @type {Line3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst l = new Line3();\r\n\r\n\t/**\r\n\t * A box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst b$8 = new Box3();\r\n\r\n\t/**\r\n\t * A box.\r\n\t *\r\n\t * @type {Box3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst d = new Box3();\r\n\r\n\t/**\r\n\t * A ray.\r\n\t *\r\n\t * @type {Ray}\r\n\t * @private\r\n\t */\r\n\r\n\tconst r$1 = new Ray();\r\n\r\n\t/**\r\n\t * A world octree raycaster.\r\n\t *\r\n\t * This raycaster is a specialised hybrid that uses a voxel traversal algorithm\r\n\t * to iterate over the octants of the highest LOD grid and an octree traversal\r\n\t * algorithm to raycast the identified subtrees.\r\n\t *\r\n\t * The voxel traversal implementation is a 3D supercover variant of the Digital\r\n\t * Differential Analyzer (DDA) line algorithm and is similar to the Bresenham\r\n\t * algorithm. The octree traversal algorithm relies on octant child existence\r\n\t * information to skip empty space and to avoid hashmap lookup misses.\r\n\t *\r\n\t * References:\r\n\t *\r\n\t *  \"Voxel Traversal along a 3D Line\"\r\n\t *  by D. Cohen (1994)\r\n\t *\r\n\t *  \"An Efficient Parametric Algorithm for Octree Traversal\"\r\n\t *  by J. Revelles et al. (2000)\r\n\t */\n\n\t/**\r\n\t * A vector.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst v$7 = new Vector3();\r\n\r\n\t/**\r\n\t * An octree that subdivides space for fast spatial searches.\r\n\t *\r\n\t * The purpose of this linear octree is to efficiently organise volume data. It\r\n\t * allows direct access to different LOD layers, octant neighbours and parents.\r\n\t *\r\n\t * The world octree is axis-aligned and cannot be rotated.\r\n\t */\n\n\t/**\r\n\t * World octree space partitioning components.\r\n\t *\r\n\t * @module rabbit-hole/octree/world\r\n\t */\n\n\t/**\r\n\t * Space partitioning components.\r\n\t *\r\n\t * @module rabbit-hole/octree\r\n\t */\n\n\t/**\r\n\t * Utility components.\r\n\t *\r\n\t * @module rabbit-hole/utils\r\n\t */\n\n\t/**\r\n\t * A CSG operation.\r\n\t */\r\n\r\n\tclass Operation {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new operation.\r\n\t\t *\r\n\t\t * @param {OperationType} type - The type of this operation.\r\n\t\t * @param {Operation} ...children - Child operations.\r\n\t\t */\r\n\r\n\t\tconstructor(type, ...children) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The type of this operation.\r\n\t\t\t *\r\n\t\t\t * @type {OperationType}\r\n\t\t\t */\r\n\r\n\t\t\tthis.type = type;\r\n\r\n\t\t\t/**\r\n\t\t\t * A list of operations.\r\n\t\t\t *\r\n\t\t\t * Right-hand side operands have precedence, meaning that the result of the\r\n\t\t\t * first item in the list will be dominated by the result of the second one,\r\n\t\t\t * etc.\r\n\t\t\t *\r\n\t\t\t * @type {Operation[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.children = children;\r\n\r\n\t\t\t/**\r\n\t\t\t * The bounding box of this operation.\r\n\t\t\t *\r\n\t\t\t * @type {Box3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.bbox = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The bounding box of this operation.\r\n\t\t *\r\n\t\t * @type {Box3}\r\n\t\t */\r\n\r\n\t\tget boundingBox() {\r\n\r\n\t\t\treturn (this.bbox !== null) ? this.bbox : this.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the bounding box of this operation.\r\n\t\t *\r\n\t\t * @return {Box3} The bounding box.\r\n\t\t */\r\n\r\n\t\tcomputeBoundingBox() {\r\n\r\n\t\t\tconst children = this.children;\r\n\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tthis.bbox = new Box3();\r\n\r\n\t\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t\tthis.bbox.union(children[i].boundingBox);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.bbox;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A union operation.\r\n\t */\r\n\r\n\tclass Union extends Operation {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new union operation.\r\n\t\t *\r\n\t\t * @param {...Operation} children - Child operations.\r\n\t\t */\r\n\r\n\t\tconstructor(...children) {\r\n\r\n\t\t\tsuper(OperationType.UNION, ...children);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Updates the specified material index.\r\n\t\t *\r\n\t\t * @param {Number} index - The index of the material index that needs to be updated.\r\n\t\t * @param {HermiteData} data0 - The target volume data.\r\n\t\t * @param {HermiteData} data1 - Predominant volume data.\r\n\t\t */\r\n\r\n\t\tupdateMaterialIndex(index, data0, data1) {\r\n\r\n\t\t\tconst materialIndex = data1.materialIndices[index];\r\n\r\n\t\t\tif(materialIndex !== Material.AIR) {\r\n\r\n\t\t\t\tdata0.setMaterialIndex(index, materialIndex);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Selects the edge that is closer to the non-solid grid point.\r\n\t\t *\r\n\t\t * @param {Edge} edge0 - An existing edge.\r\n\t\t * @param {Edge} edge1 - A predominant edge.\r\n\t\t * @param {Boolean} s - Whether the starting point of the edge is solid.\r\n\t\t * @return {Edge} The selected edge.\r\n\t\t */\r\n\r\n\t\tselectEdge(edge0, edge1, s) {\r\n\r\n\t\t\treturn s ?\r\n\t\t\t\t((edge0.t > edge1.t) ? edge0 : edge1) :\r\n\t\t\t\t((edge0.t < edge1.t) ? edge0 : edge1);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A difference operation.\r\n\t */\r\n\r\n\tclass Difference extends Operation {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new difference operation.\r\n\t\t *\r\n\t\t * @param {Operation} ...children - Child operations.\r\n\t\t */\r\n\r\n\t\tconstructor(...children) {\r\n\r\n\t\t\tsuper(OperationType.DIFFERENCE, ...children);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Updates the specified material index.\r\n\t\t *\r\n\t\t * @param {Number} index - The index of the material index that needs to be updated.\r\n\t\t * @param {HermiteData} data0 - The target volume data.\r\n\t\t * @param {HermiteData} data1 - Predominant volume data.\r\n\t\t */\r\n\r\n\t\tupdateMaterialIndex(index, data0, data1) {\r\n\r\n\t\t\tif(data1.materialIndices[index] !== Material.AIR) {\r\n\r\n\t\t\t\tdata0.setMaterialIndex(index, Material.AIR);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Selects the edge that is closer to the solid grid point.\r\n\t\t *\r\n\t\t * @param {Edge} edge0 - An existing edge.\r\n\t\t * @param {Edge} edge1 - A predominant edge.\r\n\t\t * @param {Boolean} s - Whether the starting point of the edge is solid.\r\n\t\t * @return {Edge} The selected edge.\r\n\t\t */\r\n\r\n\t\tselectEdge(edge0, edge1, s) {\r\n\r\n\t\t\treturn s ?\r\n\t\t\t\t((edge0.t < edge1.t) ? edge0 : edge1) :\r\n\t\t\t\t((edge0.t > edge1.t) ? edge0 : edge1);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * An intersection operation.\r\n\t */\r\n\r\n\tclass Intersection extends Operation {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new intersection operation.\r\n\t\t *\r\n\t\t * @param {...Operation} children - Child operations.\r\n\t\t */\r\n\r\n\t\tconstructor(...children) {\r\n\r\n\t\t\tsuper(OperationType.INTERSECTION, ...children);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Updates the specified material index.\r\n\t\t *\r\n\t\t * @param {Number} index - The index of the material index that needs to be updated.\r\n\t\t * @param {HermiteData} data0 - The target volume data.\r\n\t\t * @param {HermiteData} data1 - Predominant volume data.\r\n\t\t */\r\n\r\n\t\tupdateMaterialIndex(index, data0, data1) {\r\n\r\n\t\t\tconst materialIndex = data1.materialIndices[index];\r\n\r\n\t\t\tdata0.setMaterialIndex(index, (data0.materialIndices[index] !== Material.AIR && materialIndex !== Material.AIR) ? materialIndex : Material.AIR);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Selects the edge that is closer to the solid grid point.\r\n\t\t *\r\n\t\t * @param {Edge} edge0 - An existing edge.\r\n\t\t * @param {Edge} edge1 - A predominant edge.\r\n\t\t * @param {Boolean} s - Whether the starting point of the edge is solid.\r\n\t\t * @return {Edge} The selected edge.\r\n\t\t */\r\n\r\n\t\tselectEdge(edge0, edge1, s) {\r\n\r\n\t\t\treturn s ?\r\n\t\t\t\t((edge0.t < edge1.t) ? edge0 : edge1) :\r\n\t\t\t\t((edge0.t > edge1.t) ? edge0 : edge1);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * The world size of the current data cell.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tlet cellSize = 0;\r\n\r\n\t/**\r\n\t * The lower bounds of the current data cell.\r\n\t *\r\n\t * @type {Vector3}\r\n\t * @private\r\n\t */\r\n\r\n\tconst cellPosition = new Vector3();\r\n\r\n\t/**\r\n\t * Finds out which grid points lie inside the area of the given operation.\r\n\t *\r\n\t * @private\r\n\t * @param {Operation} operation - A CSG operation.\r\n\t * @return {Box3} The index bounds.\r\n\t */\r\n\r\n\tfunction computeIndexBounds(operation) {\r\n\r\n\t\tconst s = cellSize;\r\n\t\tconst n = HermiteData.resolution;\r\n\r\n\t\tconst min = new Vector3(0, 0, 0);\r\n\t\tconst max = new Vector3(n, n, n);\r\n\r\n\t\tconst region = new Box3(cellPosition, cellPosition.clone().addScalar(cellSize));\r\n\r\n\t\tif(operation.type !== OperationType.INTERSECTION) {\r\n\r\n\t\t\tif(operation.boundingBox.intersectsBox(region)) {\r\n\r\n\t\t\t\tmin.copy(operation.boundingBox.min).max(region.min).sub(region.min);\r\n\r\n\t\t\t\tmin.x = Math.ceil(min.x * n / s);\r\n\t\t\t\tmin.y = Math.ceil(min.y * n / s);\r\n\t\t\t\tmin.z = Math.ceil(min.z * n / s);\r\n\r\n\t\t\t\tmax.copy(operation.boundingBox.max).min(region.max).sub(region.min);\r\n\r\n\t\t\t\tmax.x = Math.floor(max.x * n / s);\r\n\t\t\t\tmax.y = Math.floor(max.y * n / s);\r\n\t\t\t\tmax.z = Math.floor(max.z * n / s);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// The chunk is unaffected by this operation.\r\n\t\t\t\tmin.set(n, n, n);\r\n\t\t\t\tmax.set(0, 0, 0);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn new Box3(min, max);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Combines material indices.\r\n\t *\r\n\t * @private\r\n\t * @param {Operation} operation - A CSG operation.\r\n\t * @param {HermiteData} data0 - A target data set.\r\n\t * @param {HermiteData} data1 - A predominant data set.\r\n\t * @param {Box3} bounds - Grid iteration limits.\r\n\t */\r\n\r\n\tfunction combineMaterialIndices(operation, data0, data1, bounds) {\r\n\r\n\t\tconst n = HermiteData.resolution;\r\n\t\tconst m = n + 1;\r\n\t\tconst mm = m * m;\r\n\r\n\t\tconst X = bounds.max.x;\r\n\t\tconst Y = bounds.max.y;\r\n\t\tconst Z = bounds.max.z;\r\n\r\n\t\tlet x, y, z;\r\n\r\n\t\tfor(z = bounds.min.z; z <= Z; ++z) {\r\n\r\n\t\t\tfor(y = bounds.min.y; y <= Y; ++y) {\r\n\r\n\t\t\t\tfor(x = bounds.min.x; x <= X; ++x) {\r\n\r\n\t\t\t\t\toperation.updateMaterialIndex((z * mm + y * m + x), data0, data1);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Generates material indices.\r\n\t *\r\n\t * @private\r\n\t * @param {DensityFunction} operation - A CSG operation.\r\n\t * @param {HermiteData} data - A target data set.\r\n\t * @param {Box3} bounds - Grid iteration limits.\r\n\t */\r\n\r\n\tfunction generateMaterialIndices(operation, data, bounds) {\r\n\r\n\t\tconst s = cellSize;\r\n\t\tconst n = HermiteData.resolution;\r\n\t\tconst m = n + 1;\r\n\t\tconst mm = m * m;\r\n\r\n\t\tconst materialIndices = data.materialIndices;\r\n\r\n\t\tconst base = cellPosition;\r\n\t\tconst offset = new Vector3();\r\n\t\tconst position = new Vector3();\r\n\r\n\t\tconst X = bounds.max.x;\r\n\t\tconst Y = bounds.max.y;\r\n\t\tconst Z = bounds.max.z;\r\n\r\n\t\tlet materialIndex;\r\n\t\tlet materials = 0;\r\n\r\n\t\tlet x, y, z;\r\n\r\n\t\tfor(z = bounds.min.z; z <= Z; ++z) {\r\n\r\n\t\t\toffset.z = z * s / n;\r\n\r\n\t\t\tfor(y = bounds.min.y; y <= Y; ++y) {\r\n\r\n\t\t\t\toffset.y = y * s / n;\r\n\r\n\t\t\t\tfor(x = bounds.min.x; x <= X; ++x) {\r\n\r\n\t\t\t\t\toffset.x = x * s / n;\r\n\r\n\t\t\t\t\tmaterialIndex = operation.generateMaterialIndex(position.addVectors(base, offset));\r\n\r\n\t\t\t\t\tif(materialIndex !== Material.AIR) {\r\n\r\n\t\t\t\t\t\tmaterialIndices[z * mm + y * m + x] = materialIndex;\r\n\r\n\t\t\t\t\t\t++materials;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdata.materials = materials;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Combines edges.\r\n\t *\r\n\t * @private\r\n\t * @param {Operation} operation - A CSG operation.\r\n\t * @param {HermiteData} data0 - A target data set.\r\n\t * @param {HermiteData} data1 - A predominant data set.\r\n\t * @return {Object} The generated edge data.\r\n\t */\r\n\r\n\tfunction combineEdges(operation, data0, data1) {\r\n\r\n\t\tconst n = HermiteData.resolution;\r\n\t\tconst m = n + 1;\r\n\t\tconst mm = m * m;\r\n\r\n\t\tconst indexOffsets = new Uint32Array([1, m, mm]);\r\n\t\tconst materialIndices = data0.materialIndices;\r\n\r\n\t\tconst edge1 = new Edge();\r\n\t\tconst edge0 = new Edge();\r\n\r\n\t\tconst edgeData1 = data1.edgeData;\r\n\t\tconst edgeData0 = data0.edgeData;\r\n\r\n\t\tconst lengths = new Uint32Array(3);\r\n\t\tconst edgeCount = EdgeData.calculate1DEdgeCount(n);\r\n\r\n\t\tconst edgeData = new EdgeData(\r\n\t\t\tMath.min(edgeCount, edgeData0.indices[0].length + edgeData1.indices[0].length),\r\n\t\t\tMath.min(edgeCount, edgeData0.indices[1].length + edgeData1.indices[1].length),\r\n\t\t\tMath.min(edgeCount, edgeData0.indices[2].length + edgeData1.indices[2].length)\r\n\t\t);\r\n\r\n\t\tlet edges1, zeroCrossings1, normals1;\r\n\t\tlet edges0, zeroCrossings0, normals0;\r\n\t\tlet edges, zeroCrossings, normals;\r\n\t\tlet indexOffset;\r\n\r\n\t\tlet indexA1, indexB1;\r\n\t\tlet indexA0, indexB0;\r\n\r\n\t\tlet m1, m2;\r\n\t\tlet edge;\r\n\r\n\t\tlet c, d, i, j, il, jl;\r\n\r\n\t\t// Process the edges along the X-axis, then Y and finally Z.\r\n\t\tfor(c = 0, d = 0; d < 3; c = 0, ++d) {\r\n\r\n\t\t\tedges1 = edgeData1.indices[d];\r\n\t\t\tedges0 = edgeData0.indices[d];\r\n\t\t\tedges = edgeData.indices[d];\r\n\r\n\t\t\tzeroCrossings1 = edgeData1.zeroCrossings[d];\r\n\t\t\tzeroCrossings0 = edgeData0.zeroCrossings[d];\r\n\t\t\tzeroCrossings = edgeData.zeroCrossings[d];\r\n\r\n\t\t\tnormals1 = edgeData1.normals[d];\r\n\t\t\tnormals0 = edgeData0.normals[d];\r\n\t\t\tnormals = edgeData.normals[d];\r\n\r\n\t\t\tindexOffset = indexOffsets[d];\r\n\r\n\t\t\til = edges1.length;\r\n\t\t\tjl = edges0.length;\r\n\r\n\t\t\t// Process all generated edges.\r\n\t\t\tfor(i = 0, j = 0; i < il; ++i) {\r\n\r\n\t\t\t\tindexA1 = edges1[i];\r\n\t\t\t\tindexB1 = indexA1 + indexOffset;\r\n\r\n\t\t\t\tm1 = materialIndices[indexA1];\r\n\t\t\t\tm2 = materialIndices[indexB1];\r\n\r\n\t\t\t\tif(m1 !== m2 && (m1 === Material.AIR || m2 === Material.AIR)) {\r\n\r\n\t\t\t\t\tedge1.t = zeroCrossings1[i];\r\n\t\t\t\t\tedge1.n.x = normals1[i * 3];\r\n\t\t\t\t\tedge1.n.y = normals1[i * 3 + 1];\r\n\t\t\t\t\tedge1.n.z = normals1[i * 3 + 2];\r\n\r\n\t\t\t\t\tif(operation.type === OperationType.DIFFERENCE) {\r\n\r\n\t\t\t\t\t\tedge1.n.negate();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tedge = edge1;\r\n\r\n\t\t\t\t\t// Process existing edges up to the generated edge.\r\n\t\t\t\t\twhile(j < jl && edges0[j] <= indexA1) {\r\n\r\n\t\t\t\t\t\tindexA0 = edges0[j];\r\n\t\t\t\t\t\tindexB0 = indexA0 + indexOffset;\r\n\r\n\t\t\t\t\t\tedge0.t = zeroCrossings0[j];\r\n\t\t\t\t\t\tedge0.n.x = normals0[j * 3];\r\n\t\t\t\t\t\tedge0.n.y = normals0[j * 3 + 1];\r\n\t\t\t\t\t\tedge0.n.z = normals0[j * 3 + 2];\r\n\r\n\t\t\t\t\t\tm1 = materialIndices[indexA0];\r\n\r\n\t\t\t\t\t\tif(indexA0 < indexA1) {\r\n\r\n\t\t\t\t\t\t\tm2 = materialIndices[indexB0];\r\n\r\n\t\t\t\t\t\t\tif(m1 !== m2 && (m1 === Material.AIR || m2 === Material.AIR)) {\r\n\r\n\t\t\t\t\t\t\t\t// The edge exhibits a material change and there is no conflict.\r\n\t\t\t\t\t\t\t\tedges[c] = indexA0;\r\n\t\t\t\t\t\t\t\tzeroCrossings[c] = edge0.t;\r\n\t\t\t\t\t\t\t\tnormals[c * 3] = edge0.n.x;\r\n\t\t\t\t\t\t\t\tnormals[c * 3 + 1] = edge0.n.y;\r\n\t\t\t\t\t\t\t\tnormals[c * 3 + 2] = edge0.n.z;\r\n\r\n\t\t\t\t\t\t\t\t++c;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// Resolve the conflict.\r\n\t\t\t\t\t\t\tedge = operation.selectEdge(edge0, edge1, (m1 === Material.SOLID));\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t++j;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tedges[c] = indexA1;\r\n\t\t\t\t\tzeroCrossings[c] = edge.t;\r\n\t\t\t\t\tnormals[c * 3] = edge.n.x;\r\n\t\t\t\t\tnormals[c * 3 + 1] = edge.n.y;\r\n\t\t\t\t\tnormals[c * 3 + 2] = edge.n.z;\r\n\r\n\t\t\t\t\t++c;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Collect remaining edges.\r\n\t\t\twhile(j < jl) {\r\n\r\n\t\t\t\tindexA0 = edges0[j];\r\n\t\t\t\tindexB0 = indexA0 + indexOffset;\r\n\r\n\t\t\t\tm1 = materialIndices[indexA0];\r\n\t\t\t\tm2 = materialIndices[indexB0];\r\n\r\n\t\t\t\tif(m1 !== m2 && (m1 === Material.AIR || m2 === Material.AIR)) {\r\n\r\n\t\t\t\t\tedges[c] = indexA0;\r\n\t\t\t\t\tzeroCrossings[c] = zeroCrossings0[j];\r\n\t\t\t\t\tnormals[c * 3] = normals0[j * 3];\r\n\t\t\t\t\tnormals[c * 3 + 1] = normals0[j * 3 + 1];\r\n\t\t\t\t\tnormals[c * 3 + 2] = normals0[j * 3 + 2];\r\n\r\n\t\t\t\t\t++c;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t++j;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlengths[d] = c;\r\n\r\n\t\t}\r\n\r\n\t\treturn { edgeData, lengths };\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Generates edge data.\r\n\t *\r\n\t * @private\r\n\t * @param {DensityFunction} operation - A CSG operation.\r\n\t * @param {HermiteData} data - A target data set.\r\n\t * @param {Box3} bounds - Grid iteration limits.\r\n\t * @return {Object} The generated edge data.\r\n\t */\r\n\r\n\tfunction generateEdges(operation, data, bounds) {\r\n\r\n\t\tconst s = cellSize;\r\n\t\tconst n = HermiteData.resolution;\r\n\t\tconst m = n + 1;\r\n\t\tconst mm = m * m;\r\n\r\n\t\tconst indexOffsets = new Uint32Array([1, m, mm]);\r\n\t\tconst materialIndices = data.materialIndices;\r\n\r\n\t\tconst base = cellPosition;\r\n\t\tconst offsetA = new Vector3();\r\n\t\tconst offsetB = new Vector3();\r\n\t\tconst edge = new Edge();\r\n\r\n\t\tconst lengths = new Uint32Array(3);\r\n\t\tconst edgeData = new EdgeData(EdgeData.calculate1DEdgeCount(n));\r\n\r\n\t\tlet edges, zeroCrossings, normals, indexOffset;\r\n\t\tlet indexA, indexB;\r\n\r\n\t\tlet minX, minY, minZ;\r\n\t\tlet maxX, maxY, maxZ;\r\n\r\n\t\tlet c, d, a, axis;\r\n\t\tlet x, y, z;\r\n\r\n\t\t// Process the edges along the X-axis, then Y and finally Z.\r\n\t\tfor(a = 4, c = 0, d = 0; d < 3; a >>= 1, c = 0, ++d) {\r\n\r\n\t\t\t// X: [1, 0, 0] Y: [0, 1, 0] Z: [0, 0, 1].\r\n\t\t\taxis = pattern[a];\r\n\r\n\t\t\tedges = edgeData.indices[d];\r\n\t\t\tzeroCrossings = edgeData.zeroCrossings[d];\r\n\t\t\tnormals = edgeData.normals[d];\r\n\t\t\tindexOffset = indexOffsets[d];\r\n\r\n\t\t\tminX = bounds.min.x; maxX = bounds.max.x;\r\n\t\t\tminY = bounds.min.y; maxY = bounds.max.y;\r\n\t\t\tminZ = bounds.min.z; maxZ = bounds.max.z;\r\n\r\n\t\t\t/* Include edges that straddle the bounding box and avoid processing grid\r\n\t\t\tpoints at chunk borders. */\r\n\t\t\tswitch(d) {\r\n\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tminX = Math.max(minX - 1, 0);\r\n\t\t\t\t\tmaxX = Math.min(maxX, n - 1);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tminY = Math.max(minY - 1, 0);\r\n\t\t\t\t\tmaxY = Math.min(maxY, n - 1);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tminZ = Math.max(minZ - 1, 0);\r\n\t\t\t\t\tmaxZ = Math.min(maxZ, n - 1);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor(z = minZ; z <= maxZ; ++z) {\r\n\r\n\t\t\t\tfor(y = minY; y <= maxY; ++y) {\r\n\r\n\t\t\t\t\tfor(x = minX; x <= maxX; ++x) {\r\n\r\n\t\t\t\t\t\tindexA = z * mm + y * m + x;\r\n\t\t\t\t\t\tindexB = indexA + indexOffset;\r\n\r\n\t\t\t\t\t\t// Check if the edge exhibits a material change.\r\n\t\t\t\t\t\tif(materialIndices[indexA] !== materialIndices[indexB]) {\r\n\r\n\t\t\t\t\t\t\toffsetA.set(\r\n\t\t\t\t\t\t\t\tx * s / n,\r\n\t\t\t\t\t\t\t\ty * s / n,\r\n\t\t\t\t\t\t\t\tz * s / n\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\toffsetB.set(\r\n\t\t\t\t\t\t\t\t(x + axis[0]) * s / n,\r\n\t\t\t\t\t\t\t\t(y + axis[1]) * s / n,\r\n\t\t\t\t\t\t\t\t(z + axis[2]) * s / n\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tedge.a.addVectors(base, offsetA);\r\n\t\t\t\t\t\t\tedge.b.addVectors(base, offsetB);\r\n\r\n\t\t\t\t\t\t\t// Create and store the edge data.\r\n\t\t\t\t\t\t\toperation.generateEdge(edge);\r\n\r\n\t\t\t\t\t\t\tedges[c] = indexA;\r\n\t\t\t\t\t\t\tzeroCrossings[c] = edge.t;\r\n\t\t\t\t\t\t\tnormals[c * 3] = edge.n.x;\r\n\t\t\t\t\t\t\tnormals[c * 3 + 1] = edge.n.y;\r\n\t\t\t\t\t\t\tnormals[c * 3 + 2] = edge.n.z;\r\n\r\n\t\t\t\t\t\t\t++c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlengths[d] = c;\r\n\r\n\t\t}\r\n\r\n\t\treturn { edgeData, lengths };\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Either generates or combines volume data based on the operation type.\r\n\t *\r\n\t * @private\r\n\t * @param {Operation} operation - A CSG operation.\r\n\t * @param {HermiteData} data0 - A target data set. May be empty or full.\r\n\t * @param {HermiteData} [data1] - A predominant data set. Cannot be null.\r\n\t */\r\n\r\n\tfunction update(operation, data0, data1) {\r\n\r\n\t\tconst bounds = computeIndexBounds(operation);\r\n\r\n\t\tlet result, edgeData, lengths, d;\r\n\t\tlet done = false;\r\n\r\n\t\t// Grid points.\r\n\t\tif(operation.type === OperationType.DENSITY_FUNCTION) {\r\n\r\n\t\t\tgenerateMaterialIndices(operation, data0, bounds);\r\n\r\n\t\t} else if(data0.empty) {\r\n\r\n\t\t\tif(operation.type === OperationType.UNION) {\r\n\r\n\t\t\t\tdata0.set(data1);\r\n\t\t\t\tdone = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif(!(data0.full && operation.type === OperationType.UNION)) {\r\n\r\n\t\t\t\tcombineMaterialIndices(operation, data0, data1, bounds);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Edges.\r\n\t\tif(!done && !data0.empty && !data0.full) {\r\n\r\n\t\t\tresult = (operation.type === OperationType.DENSITY_FUNCTION) ?\r\n\t\t\t\tgenerateEdges(operation, data0, bounds) :\r\n\t\t\t\tcombineEdges(operation, data0, data1);\r\n\r\n\t\t\tedgeData = result.edgeData;\r\n\t\t\tlengths = result.lengths;\r\n\r\n\t\t\t// Cut off empty data.\r\n\t\t\tfor(d = 0; d < 3; ++d) {\r\n\r\n\t\t\t\tedgeData.indices[d] = edgeData.indices[d].slice(0, lengths[d]);\r\n\t\t\t\tedgeData.zeroCrossings[d] = edgeData.zeroCrossings[d].slice(0, lengths[d]);\r\n\t\t\t\tedgeData.normals[d] = edgeData.normals[d].slice(0, lengths[d] * 3);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdata0.edgeData = edgeData;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Executes the given operation to generate data.\r\n\t *\r\n\t * @private\r\n\t * @param {Operation} operation - An operation.\r\n\t * @return {HermiteData} The generated data or null if the data is empty.\r\n\t */\r\n\r\n\tfunction execute(operation) {\r\n\r\n\t\tconst children = operation.children;\r\n\r\n\t\tlet result, data;\r\n\t\tlet i, l;\r\n\r\n\t\tif(operation.type === OperationType.DENSITY_FUNCTION) {\r\n\r\n\t\t\t// Create a data target.\r\n\t\t\tresult = new HermiteData();\r\n\r\n\t\t\t// Use the density function to generate data.\r\n\t\t\tupdate(operation, result);\r\n\r\n\t\t}\r\n\r\n\t\t// Union, Difference or Intersection.\r\n\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t// Generate the full result of the child operation recursively.\r\n\t\t\tdata = execute(children[i]);\r\n\r\n\t\t\tif(result === undefined) {\r\n\r\n\t\t\t\tresult = data;\r\n\r\n\t\t\t} else if(data !== null) {\r\n\r\n\t\t\t\tif(result === null) {\r\n\r\n\t\t\t\t\tif(operation.type === OperationType.UNION) {\r\n\r\n\t\t\t\t\t\t// Build upon the first non-empty data.\r\n\t\t\t\t\t\tresult = data;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Combine the two data sets.\r\n\t\t\t\t\tupdate(operation, result, data);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if(operation.type === OperationType.INTERSECTION) {\r\n\r\n\t\t\t\t// An intersection with nothing results in nothing.\r\n\t\t\t\tresult = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(result === null && operation.type !== OperationType.UNION) {\r\n\r\n\t\t\t\t// Further subtractions and intersections would have no effect.\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn (result !== null && result.empty) ? null : result;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Constructive Solid Geometry combines Signed Distance Functions by using\r\n\t * Boolean operators to generate and transform volume data.\r\n\t */\r\n\r\n\tclass ConstructiveSolidGeometry {\r\n\r\n\t\t/**\r\n\t\t * Transforms the given Hermite data in two steps:\r\n\t\t *\r\n\t\t *  1. Generate data by executing the given SDF\r\n\t\t *  2. Combine the generated data with the given data\r\n\t\t *\r\n\t\t * @param {Number[]} min - The lower bounds of the volume data cell.\r\n\t\t * @param {Number} size - The size of the volume data cell.\r\n\t\t * @param {HermiteData} data - The volume data that should be modified.\r\n\t\t * @param {SignedDistanceFunction} sdf - An SDF.\r\n\t\t * @return {HermiteData} The modified, uncompressed data or null if the result is empty.\r\n\t\t */\r\n\r\n\t\tstatic run(min, size, data, sdf) {\r\n\r\n\t\t\tcellPosition.fromArray(min);\r\n\t\t\tcellSize = size;\r\n\r\n\t\t\tif(data === null) {\r\n\r\n\t\t\t\tif(sdf.operation === OperationType.UNION) {\r\n\r\n\t\t\t\t\t// Prepare an empty target.\r\n\t\t\t\t\tdata = new HermiteData(false);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tdata.decompress();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Step 1.\r\n\t\t\tlet operation = sdf.toCSG();\r\n\r\n\t\t\tconst generatedData = (data !== null) ? execute(operation) : null;\r\n\r\n\t\t\tif(generatedData !== null) {\r\n\r\n\t\t\t\t// Wrap the operation in a super operation.\r\n\t\t\t\tswitch(sdf.operation) {\r\n\r\n\t\t\t\t\tcase OperationType.UNION:\r\n\t\t\t\t\t\toperation = new Union(operation);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase OperationType.DIFFERENCE:\r\n\t\t\t\t\t\toperation = new Difference(operation);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase OperationType.INTERSECTION:\r\n\t\t\t\t\t\toperation = new Intersection(operation);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Step 2.\r\n\t\t\t\tupdate(operation, data, generatedData);\r\n\r\n\t\t\t\t// Provoke an isosurface extraction.\r\n\t\t\t\tdata.contoured = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn (data !== null && data.empty) ? null : data;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * The isovalue.\r\n\t *\r\n\t * @type {Number}\r\n\t * @private\r\n\t */\r\n\r\n\tconst ISOVALUE = 0.0;\r\n\r\n\t/**\r\n\t * An operation that describes a density field.\r\n\t */\r\n\r\n\tclass DensityFunction extends Operation {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new density function operation.\r\n\t\t *\r\n\t\t * @param {SignedDistanceFunction} sdf - An SDF.\r\n\t\t */\r\n\r\n\t\tconstructor(sdf) {\r\n\r\n\t\t\tsuper(OperationType.DENSITY_FUNCTION);\r\n\r\n\t\t\t/**\r\n\t\t\t * An SDF.\r\n\t\t\t *\r\n\t\t\t * @type {SignedDistanceFunction}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.sdf = sdf;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates a bounding box for this operation.\r\n\t\t *\r\n\t\t * @return {Box3} The bounding box.\r\n\t\t */\r\n\r\n\t\tcomputeBoundingBox() {\r\n\r\n\t\t\tthis.bbox = this.sdf.computeBoundingBox();\r\n\r\n\t\t\treturn this.bbox;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the material index for the given world position.\r\n\t\t *\r\n\t\t * @param {Vector3} position - The world position of the material index.\r\n\t\t * @return {Number} The material index.\r\n\t\t */\r\n\r\n\t\tgenerateMaterialIndex(position) {\r\n\r\n\t\t\treturn (this.sdf.sample(position) <= ISOVALUE) ? this.sdf.material : Material.AIR;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Generates surface intersection data for the specified edge.\r\n\t\t *\r\n\t\t * @param {Edge} edge - The edge that should be processed.\r\n\t\t */\r\n\r\n\t\tgenerateEdge(edge) {\r\n\r\n\t\t\tedge.approximateZeroCrossing(this.sdf);\r\n\t\t\tedge.computeSurfaceNormal(this.sdf);\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A collection of Constructive Solid Geometry components.\r\n\t *\r\n\t * @module rabbit-hole/volume/csg\r\n\t */\n\n\t/**\r\n\t * An abstract Signed Distance Function.\r\n\t *\r\n\t * An SDF describes the signed Euclidean distance to the surface of an object,\r\n\t * effectively describing its density at every point in 3D space. It yields\r\n\t * negative values for points that lie inside the volume and positive values\r\n\t * for points outside. The value is zero at the exact boundary of the object.\r\n\t *\r\n\t * @implements {Serializable}\r\n\t * @implements {TransferableContainer}\r\n\t */\r\n\r\n\tclass SignedDistanceFunction {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new base SDF.\r\n\t\t *\r\n\t\t * @param {SDFType} type - The type of the SDF.\r\n\t\t * @param {Number} [material=Material.SOLID] - A material index. Must be an integer in the range of 1 to 255.\r\n\t\t */\r\n\r\n\t\tconstructor(type, material = Material.SOLID) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The type of this SDF.\r\n\t\t\t *\r\n\t\t\t * @type {SDFType}\r\n\t\t\t */\r\n\r\n\t\t\tthis.type = type;\r\n\r\n\t\t\t/**\r\n\t\t\t * The operation type.\r\n\t\t\t *\r\n\t\t\t * @type {OperationType}\r\n\t\t\t */\r\n\r\n\t\t\tthis.operation = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A material index.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.material = Math.min(255, Math.max(Material.SOLID, Math.trunc(material)));\r\n\r\n\t\t\t/**\r\n\t\t\t * A list of SDFs.\r\n\t\t\t *\r\n\t\t\t * SDFs can be chained to build CSG expressions.\r\n\t\t\t *\r\n\t\t\t * @type {SignedDistanceFunction[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.children = [];\r\n\r\n\t\t\t/**\r\n\t\t\t * The bounding box of this SDF.\r\n\t\t\t *\r\n\t\t\t * @type {Box3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.bbox = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The bounding box of this SDF.\r\n\t\t *\r\n\t\t * @type {Box3}\r\n\t\t */\r\n\r\n\t\tget boundingBox() {\r\n\r\n\t\t\treturn (this.bbox !== null) ? this.bbox : this.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The complete bounding box of this SDF.\r\n\t\t *\r\n\t\t * @type {Box3}\r\n\t\t */\r\n\r\n\t\tget completeBoundingBox() {\r\n\r\n\t\t\tconst children = this.children;\r\n\t\t\tconst bbox = this.boundingBox.clone();\r\n\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t\tbbox.union(children[i].completeBoundingBox);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn bbox;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the CSG operation type of this SDF.\r\n\t\t *\r\n\t\t * @param {OperationType} operation - The CSG operation type.\r\n\t\t * @return {SignedDistanceFunction} This SDF.\r\n\t\t */\r\n\r\n\t\tsetOperationType(operation) {\r\n\r\n\t\t\tthis.operation = operation;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds the given SDF to this one.\r\n\t\t *\r\n\t\t * @param {SignedDistanceFunction} sdf - An SDF.\r\n\t\t * @return {SignedDistanceFunction} This SDF.\r\n\t\t */\r\n\r\n\t\tunion(sdf) {\r\n\r\n\t\t\tsdf.operation = OperationType.UNION;\r\n\t\t\tthis.children.push(sdf);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Subtracts the given SDF from this one.\r\n\t\t *\r\n\t\t * @param {SignedDistanceFunction} sdf - An SDF.\r\n\t\t * @return {SignedDistanceFunction} This SDF.\r\n\t\t */\r\n\r\n\t\tsubtract(sdf) {\r\n\r\n\t\t\tsdf.operation = OperationType.DIFFERENCE;\r\n\t\t\tthis.children.push(sdf);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Intersects the given SDF with this one.\r\n\t\t *\r\n\t\t * @param {SignedDistanceFunction} sdf - An SDF.\r\n\t\t * @return {SignedDistanceFunction} This SDF.\r\n\t\t */\r\n\r\n\t\tintersect(sdf) {\r\n\r\n\t\t\tsdf.operation = OperationType.INTERSECTION;\r\n\t\t\tthis.children.push(sdf);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Translates this SDF into a CSG expression.\r\n\t\t *\r\n\t\t * @return {Operation} A CSG operation.\r\n\t\t * @example a.union(b.intersect(c)).union(d).subtract(e) => Difference(Union(a, Intersection(b, c), d), e)\r\n\t\t */\r\n\r\n\t\ttoCSG() {\r\n\r\n\t\t\tconst children = this.children;\r\n\r\n\t\t\tlet operation = new DensityFunction(this);\r\n\t\t\tlet operationType;\r\n\t\t\tlet child;\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 0, l = children.length; i < l; ++i) {\r\n\r\n\t\t\t\tchild = children[i];\r\n\r\n\t\t\t\tif(operationType !== child.operation) {\r\n\r\n\t\t\t\t\toperationType = child.operation;\r\n\r\n\t\t\t\t\tswitch(operationType) {\r\n\r\n\t\t\t\t\t\tcase OperationType.UNION:\r\n\t\t\t\t\t\t\toperation = new Union(operation);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase OperationType.DIFFERENCE:\r\n\t\t\t\t\t\t\toperation = new Difference(operation);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase OperationType.INTERSECTION:\r\n\t\t\t\t\t\t\toperation = new Intersection(operation);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\toperation.children.push(child.toCSG());\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn operation;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Serialises this SDF.\r\n\t\t *\r\n\t\t * @param {Boolean} [deflate=false] - Whether the data should be compressed if possible.\r\n\t\t * @return {Object} The serialised data.\r\n\t\t */\r\n\r\n\t\tserialize(deflate = false) {\r\n\r\n\t\t\tconst result = {\r\n\t\t\t\ttype: this.type,\r\n\t\t\t\toperation: this.operation,\r\n\t\t\t\tmaterial: this.material,\r\n\t\t\t\tparameters: null,\r\n\t\t\t\tchildren: []\r\n\t\t\t};\r\n\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 0, l = this.children.length; i < l; ++i) {\r\n\r\n\t\t\t\tresult.children.push(this.children[i].serialize(deflate));\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a list of transferable items.\r\n\t\t *\r\n\t\t * @param {Array} [transferList] - An optional target list. The transferable items will be added to this list.\r\n\t\t * @return {Transferable[]} The transfer list.\r\n\t\t */\r\n\r\n\t\tcreateTransferList(transferList = []) {\r\n\r\n\t\t\treturn transferList;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns a plain object that describes this SDF.\r\n\t\t *\r\n\t\t * @return {Object} A simple description of this SDF.\r\n\t\t */\r\n\r\n\t\ttoJSON() {\r\n\r\n\t\t\treturn this.serialize(true);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the bounding box of this SDF.\r\n\t\t *\r\n\t\t * @throws {Error} An error is thrown if the method is not overridden.\r\n\t\t * @return {Box3} The bounding box.\r\n\t\t */\r\n\r\n\t\tcomputeBoundingBox() {\r\n\r\n\t\t\tthrow new Error(\"SignedDistanceFunction#computeBoundingBox method not implemented!\");\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Samples the volume's density at the given point in space.\r\n\t\t *\r\n\t\t * @throws {Error} An error is thrown if the method is not overridden.\r\n\t\t * @param {Vector3} position - A position.\r\n\t\t * @return {Number} The Euclidean distance to the surface.\r\n\t\t */\r\n\r\n\t\tsample(position) {\r\n\r\n\t\t\tthrow new Error(\"SignedDistanceFunction#sample method not implemented!\");\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * An enumeration of SDF types.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {String} HEIGHTFIELD - A heightfield description.\r\n\t * @property {String} FRACTAL_NOISE - A fractal noise description.\r\n\t * @property {String} SUPER_PRIMITIVE - A super primitive description.\r\n\t */\r\n\r\n\tconst SDFType = {\r\n\r\n\t\tHEIGHTFIELD: \"sdf.heightfield\",\r\n\t\tFRACTAL_NOISE: \"sdf.fractalnoise\",\r\n\t\tSUPER_PRIMITIVE: \"sdf.superprimitive\"\r\n\r\n\t};\n\n\t/**\r\n\t * Fractal noise based on Perlin's technique.\r\n\t *\r\n\t * Reference:\r\n\t *  https://gpfault.net/posts/perlin-noise.txt.html\r\n\t *\r\n\t * @implements {Serializable}\r\n\t */\n\n\t/**\r\n\t * A Signed Distance Function that describes a heightfield.\r\n\t *\r\n\t * @implements {Serializable}\r\n\t */\n\n\t/**\r\n\t * The super primitive.\r\n\t *\r\n\t * A function that is able to represent a wide range of conic/rectangular-radial\r\n\t * primitives of genus 0 and 1: (round) box, sphere, cylinder, capped cone,\r\n\t * torus, capsule, pellet, pipe, etc.\r\n\t *\r\n\t * Reference:\r\n\t *  https://www.shadertoy.com/view/MsVGWG\r\n\t *\r\n\t * @implements {Serializable}\r\n\t */\r\n\r\n\tclass SuperPrimitive extends SignedDistanceFunction {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new super primitive.\r\n\t\t *\r\n\t\t * See {@link SuperPrimitivePreset} for a list of default configurations.\r\n\t\t *\r\n\t\t * @param {Object} parameters - The parameters.\r\n\t\t * @param {Array} parameters.s - The size and genus weight [x, y, z, w].\r\n\t\t * @param {Array} parameters.r - The corner radii [x, y, z].\r\n\t\t * @param {Array} [parameters.scale=1.0] - The scale.\r\n\t\t * @param {Array} [parameters.origin] - The origin [x, y, z].\r\n\t\t * @param {Number} [material] - A material index.\r\n\t\t * @example const cube = SuperPrimitive.create(SuperPrimitivePreset.CUBE);\r\n\t\t */\r\n\r\n\t\tconstructor(parameters = {}, material) {\r\n\r\n\t\t\tsuper(SDFType.SUPER_PRIMITIVE, material);\r\n\r\n\t\t\t/**\r\n\t\t\t * The origin.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t */\r\n\r\n\t\t\tthis.origin = new Vector3();\r\n\r\n\t\t\tif(parameters.origin !== undefined) {\r\n\r\n\t\t\t\tthis.origin.fromArray(parameters.origin);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * The scale.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.scale = (parameters.scale !== undefined) ? parameters.scale : 1.0;\r\n\r\n\t\t\t/**\r\n\t\t\t * The base size. The W-component affects the genus of the primitive.\r\n\t\t\t *\r\n\t\t\t * @type {Vector4}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.s0 = new Vector4(...parameters.s);\r\n\r\n\t\t\t/**\r\n\t\t\t * The base corner radii.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.r0 = new Vector3(...parameters.r);\r\n\r\n\t\t\t/**\r\n\t\t\t * The size, adjusted for further calculations.\r\n\t\t\t *\r\n\t\t\t * @type {Vector4}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.s = this.s0.clone().multiplyScalar(this.scale);\r\n\r\n\t\t\t/**\r\n\t\t\t * The corner radii, adjusted for further calculations.\r\n\t\t\t *\r\n\t\t\t * @type {Vector3}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.r = this.r0.clone().multiplyScalar(this.scale);\r\n\r\n\t\t\t/**\r\n\t\t\t * Precomputed corner rounding constants.\r\n\t\t\t *\r\n\t\t\t * @type {Vector2}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.ba = new Vector2();\r\n\r\n\t\t\t/**\r\n\t\t\t * The bottom radius offset.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.offset = 0;\r\n\r\n\t\t\t// Calculate constants ahead of time.\r\n\t\t\tthis.precompute();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Scales the volume.\r\n\t\t *\r\n\t\t * @param {Number} s - The scale.\r\n\t\t */\r\n\r\n\t\tsetScale(s) {\r\n\r\n\t\t\tthis.scale = s;\r\n\t\t\tthis.s.copy(this.s0).multiplyScalar(s);\r\n\t\t\tthis.r.copy(this.r0).multiplyScalar(s);\r\n\t\t\tthis.computeBoundingBox();\r\n\t\t\tthis.precompute();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Sets the genus factor.\r\n\t\t *\r\n\t\t * @param {Number} w - The genus factor.\r\n\t\t */\r\n\r\n\t\tsetGenus(w) {\r\n\r\n\t\t\tthis.s0.w = w;\r\n\t\t\tthis.s.copy(this.s0).multiplyScalar(this.scale);\r\n\t\t\tthis.r.copy(this.r0).multiplyScalar(this.scale);\r\n\t\t\tthis.precompute();\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Calculates the bounding box of this density field.\r\n\t\t *\r\n\t\t * @return {Box3} The bounding box.\r\n\t\t * @todo This works, but isn't very accurate. Needs further investigation.\r\n\t\t */\r\n\r\n\t\tcomputeBoundingBox() {\r\n\r\n\t\t\tconst s = this.scale * 2.0;\r\n\t\t\tconst o = this.origin;\r\n\r\n\t\t\tthis.bbox = new Box3();\r\n\t\t\tthis.bbox.min.set(o.x - s, o.y - s, o.z - s);\r\n\t\t\tthis.bbox.max.set(o.x + s, o.y + s, o.z + s);\r\n\r\n\t\t\treturn this.bbox;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Precomputes corner rounding factors.\r\n\t\t *\r\n\t\t * @private\r\n\t\t */\r\n\r\n\t\tprecompute() {\r\n\r\n\t\t\tconst s = this.s;\r\n\t\t\tconst r = this.r;\r\n\t\t\tconst ba = this.ba;\r\n\r\n\t\t\tlet divisor;\r\n\r\n\t\t\ts.x -= r.x;\r\n\t\t\ts.y -= r.x;\r\n\r\n\t\t\tr.x -= s.w;\r\n\t\t\ts.w -= r.y;\r\n\r\n\t\t\ts.z -= r.y;\r\n\r\n\t\t\tthis.offset = -2.0 * s.z;\r\n\r\n\t\t\tba.set(r.z, this.offset);\r\n\t\t\tdivisor = ba.dot(ba);\r\n\r\n\t\t\tif(divisor === 0.0) {\r\n\r\n\t\t\t\t// Y must not be 0 to prevent bad values for Z = 0 in the last term (*).\r\n\t\t\t\tba.set(0.0, -1.0);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tba.divideScalar(divisor);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Samples the volume's density at the given point in space.\r\n\t\t *\r\n\t\t * @param {Vector3} position - A position.\r\n\t\t * @return {Number} The euclidean distance to the surface.\r\n\t\t */\r\n\r\n\t\tsample(position) {\r\n\r\n\t\t\tconst o = this.origin;\r\n\t\t\tconst s = this.s;\r\n\t\t\tconst r = this.r;\r\n\t\t\tconst ba = this.ba;\r\n\r\n\t\t\tconst px = position.x - o.x;\r\n\t\t\tconst py = position.y - o.y;\r\n\t\t\tconst pz = position.z - o.z;\r\n\r\n\t\t\tconst dx = Math.abs(px) - s.x;\r\n\t\t\tconst dy = Math.abs(py) - s.y;\r\n\t\t\tconst dz = Math.abs(pz) - s.z;\r\n\r\n\t\t\tconst mx0 = Math.max(dx, 0.0);\r\n\t\t\tconst my0 = Math.max(dy, 0.0);\r\n\t\t\tconst l0 = Math.sqrt(mx0 * mx0 + my0 * my0);\r\n\r\n\t\t\tconst p = pz - s.z;\r\n\t\t\tconst q = Math.abs(l0 + Math.min(0.0, Math.max(dx, dy)) - r.x) - s.w;\r\n\r\n\t\t\tconst c = Math.min(Math.max(q * ba.x + p * ba.y, 0.0), 1.0);\r\n\t\t\tconst diagX = q - r.z * c;\r\n\t\t\tconst diagY = p - this.offset * c;\r\n\r\n\t\t\tconst hx0 = Math.max(q - r.z, 0.0);\r\n\t\t\tconst hy0 = pz + s.z;\r\n\t\t\tconst hx1 = Math.max(q, 0.0);\r\n\t\t\t// hy1 = p;\r\n\r\n\t\t\tconst diagSq = diagX * diagX + diagY * diagY;\r\n\t\t\tconst h0Sq = hx0 * hx0 + hy0 * hy0;\r\n\t\t\tconst h1Sq = hx1 * hx1 + p * p;\r\n\t\t\tconst paBa = q * -ba.y + p * ba.x;\r\n\r\n\t\t\tconst l1 = Math.sqrt(Math.min(diagSq, Math.min(h0Sq, h1Sq)));\r\n\r\n\t\t\t// (*) paBa must not be 0: if dz is also 0, the result will be wrong.\r\n\t\t\treturn l1 * Math.sign(Math.max(paBa, dz)) - r.y;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Serialises this SDF.\r\n\t\t *\r\n\t\t * @param {Boolean} [deflate=false] - Whether the data should be compressed if possible.\r\n\t\t * @return {Object} The serialised data.\r\n\t\t */\r\n\r\n\t\tserialize(deflate = false) {\r\n\r\n\t\t\tconst result = super.serialize();\r\n\r\n\t\t\tresult.parameters = {\r\n\t\t\t\torigin: this.origin.toArray(),\r\n\t\t\t\tscale: this.scale,\r\n\t\t\t\ts: this.s0.toArray(),\r\n\t\t\t\tr: this.r0.toArray()\r\n\t\t\t};\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Creates a new primitive using the specified preset.\r\n\t\t *\r\n\t\t * @param {SuperPrimitivePreset} preset - The super primitive preset.\r\n\t\t */\r\n\r\n\t\tstatic create(preset) {\r\n\r\n\t\t\tconst parameters = superPrimitivePresets[preset];\r\n\r\n\t\t\treturn new SuperPrimitive({\r\n\t\t\t\ts: parameters[0],\r\n\t\t\t\tr: parameters[1]\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A collection of parameter presets.\r\n\t *\r\n\t * @type {Array<Float32Array[]}\r\n\t * @private\r\n\t */\r\n\r\n\tconst superPrimitivePresets = [\r\n\r\n\t\t// Cube.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 1.0, 1.0]),\r\n\t\t\tnew Float32Array([0.0, 0.0, 0.0])\r\n\t\t],\r\n\r\n\t\t// Cylinder.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 1.0, 1.0]),\r\n\t\t\tnew Float32Array([1.0, 0.0, 0.0])\r\n\t\t],\r\n\r\n\t\t// Cone.\r\n\t\t[\r\n\t\t\tnew Float32Array([0.0, 0.0, 1.0, 1.0]),\r\n\t\t\tnew Float32Array([0.0, 0.0, 1.0])\r\n\t\t],\r\n\r\n\t\t// Pill.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 2.0, 1.0]),\r\n\t\t\tnew Float32Array([1.0, 1.0, 0.0])\r\n\t\t],\r\n\r\n\t\t// Sphere.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 1.0, 1.0]),\r\n\t\t\tnew Float32Array([1.0, 1.0, 0.0])\r\n\t\t],\r\n\r\n\t\t// Pellet.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 0.25, 1.0]),\r\n\t\t\tnew Float32Array([1.0, 0.25, 0.0])\r\n\t\t],\r\n\r\n\t\t// Torus.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 0.25, 0.25]),\r\n\t\t\tnew Float32Array([1.0, 0.25, 0.0])\r\n\t\t],\r\n\r\n\t\t// Pipe.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 1.0, 0.25]),\r\n\t\t\tnew Float32Array([1.0, 0.1, 0.0])\r\n\t\t],\r\n\r\n\t\t// Corridor.\r\n\t\t[\r\n\t\t\tnew Float32Array([1.0, 1.0, 1.0, 0.25]),\r\n\t\t\tnew Float32Array([0.1, 0.1, 0.0])\r\n\t\t]\r\n\r\n\t];\r\n\r\n\t/**\r\n\t * An enumeration of super primitive presets.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {Number} CUBE - A cube.\r\n\t * @property {Number} CYLINDER - A cylinder.\r\n\t * @property {Number} CONE - A cone.\r\n\t * @property {Number} PILL - A pill.\r\n\t * @property {Number} SPHERE - A sphere.\r\n\t * @property {Number} PELLET - A pellet.\r\n\t * @property {Number} TORUS - A torus.\r\n\t * @property {Number} PIPE - A pipe.\r\n\t * @property {Number} CORRIDOR - A corridor.\r\n\t */\r\n\r\n\tconst SuperPrimitivePreset = {\r\n\r\n\t\tCUBE: 0,\r\n\t\tCYLINDER: 1,\r\n\t\tCONE: 2,\r\n\t\tPILL: 3,\r\n\t\tSPHERE: 4,\r\n\t\tPELLET: 5,\r\n\t\tTORUS: 6,\r\n\t\tPIPE: 7,\r\n\t\tCORRIDOR: 8\r\n\r\n\t};\n\n\t/**\r\n\t * An SDF reviver.\r\n\t */\n\n\t/**\r\n\t * A collection of Signed Distance Function components.\r\n\t *\r\n\t * @module rabbit-hole/volume/sdf\r\n\t */\n\n\t/**\r\n\t * Volume management components.\r\n\t *\r\n\t * @module rabbit-hole/volume\r\n\t */\n\n\t/**\r\n\t * An enumeration of worker actions.\r\n\t *\r\n\t * @type {Object}\r\n\t * @property {String} EXTRACT - Isosurface extraction signal.\r\n\t * @property {String} MODIFY - Data modification signal.\r\n\t * @property {String} CONFIGURE - General configuration signal.\r\n\t * @property {String} CLOSE - Thread termination signal.\r\n\t */\n\n\t/**\r\n\t * A message.\r\n\t *\r\n\t * Messages are exchanged between different execution contexts such as a worker\r\n\t * and the main thread.\r\n\t */\n\n\t/**\r\n\t * A configuration message.\r\n\t */\n\n\t/**\r\n\t * A worker message that contains transferable data.\r\n\t */\n\n\t/**\r\n\t * An extraction request.\r\n\t */\n\n\t/**\r\n\t * An extraction response.\r\n\t */\n\n\t/**\r\n\t * A modification request.\r\n\t */\n\n\t/**\r\n\t * A modification response.\r\n\t */\n\n\t/**\r\n\t * A collection of worker messages.\r\n\t *\r\n\t * @module rabbit-hole/worker/messages\r\n\t */\n\n\t/**\r\n\t * An empty set of Hermite data.\r\n\t *\r\n\t * @type {HermiteData}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst data = new HermiteData(false);\r\n\r\n\t/**\r\n\t * A volume data processor.\r\n\t *\r\n\t * @implements {TransferableContainer}\r\n\t */\n\n\t/**\r\n\t * A surface extractor that generates a polygonal mesh from Hermite data.\r\n\t */\n\n\t/**\r\n\t * A worker message event.\r\n\t *\r\n\t * This event is dispatched by {@link ThreadPool}.\r\n\t *\r\n\t * @type {WorkerEvent}\r\n\t * @example threadPool.addEventListener(\"message\", myListener);\r\n\t */\r\n\r\n\tconst message = new WorkerEvent(\"message\");\n\n\t/**\r\n\t * Manages worker threads.\r\n\t *\r\n\t * @implements {Disposable}\r\n\t * @implements {EventListener}\r\n\t */\n\n\t/**\r\n\t * A modifier that applies CSG operations to Hermite data.\r\n\t */\n\n\t/**\r\n\t * Multithreading components.\r\n\t *\r\n\t * @module rabbit-hole/worker\r\n\t */\n\n\t/**\r\n\t * Exposure of the library components.\r\n\t *\r\n\t * @module rabbit-hole\r\n\t */\r\n\r\n\t/* export {\r\n\t\tDeserializable,\r\n\t\tDisposable,\r\n\t\tQueue,\r\n\t\tSerializable,\r\n\t\tTerrain,\r\n\t\tTransferableContainer\r\n\t} from \"./core\"; */\r\n\r\n\t/* export {\r\n\t\tClipmap,\r\n\t\tScene\r\n\t} from \"./clipmap\"; */\n\n\t/**\r\n\t * A base class for performance test reports.\r\n\t */\r\n\r\n\tclass Report {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new report.\r\n\t\t *\r\n\t\t * @param {String} [name] - The name of this report.\r\n\t\t */\r\n\r\n\t\tconstructor(name = \"Report\") {\r\n\r\n\t\t\t/**\r\n\t\t\t * The name of this report.\r\n\t\t\t *\r\n\t\t\t * @type {String}\r\n\t\t\t */\r\n\r\n\t\t\tthis.name = name;\r\n\r\n\t\t\t/**\r\n\t\t\t * A list of strings.\r\n\t\t\t *\r\n\t\t\t * @type {String[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.lines = [];\r\n\r\n\t\t\t/**\r\n\t\t\t * A list of measurment values.\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = [];\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this report.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.data = [];\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds an arbitrary line to the report.\r\n\t\t *\r\n\t\t * @param {Number} line - An arbitrary line.\r\n\t\t */\r\n\r\n\t\taddLine(line) {\r\n\r\n\t\t\tthis.lines.push(line);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a measurement reading.\r\n\t\t *\r\n\t\t * @param {Number} result - A measurement reading.\r\n\t\t */\r\n\r\n\t\taddValue(value) {\r\n\r\n\t\t\tthis.data.push(value);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns a string that describes this instance.\r\n\t\t *\r\n\t\t * @return {String} The string representation.\r\n\t\t */\r\n\r\n\t\ttoString() {\r\n\r\n\t\t\tconst lines = this.lines;\r\n\t\t\tconst data = this.data;\r\n\r\n\t\t\tlet result = this.name + \"\\n\\n\";\r\n\t\t\tlet i, l;\r\n\r\n\t\t\tfor(i = 0, l = lines.length; i < l; ++i) {\r\n\r\n\t\t\t\tresult += lines[i] + \"\\n\";\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult += \"\\nValues:\\n\";\r\n\r\n\t\t\tfor(i = 0, l = data.length; i < l; ++i) {\r\n\r\n\t\t\t\tresult += (i + 1) + \", \" + data[i] + \"\\n\";\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A base class for performance tests.\r\n\t */\r\n\r\n\tclass Test {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new test.\r\n\t\t *\r\n\t\t * @param {String} name - The name of the test.\r\n\t\t */\r\n\r\n\t\tconstructor(name = null) {\r\n\r\n\t\t\t/**\r\n\t\t\t * The name of this test.\r\n\t\t\t *\r\n\t\t\t * @type {String}\r\n\t\t\t */\r\n\r\n\t\t\tthis.name = name;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Initialises this test.\r\n\t\t *\r\n\t\t * @throws {Error} An error is thrown if the method is not overridden.\r\n\t\t * @return {Test} This test.\r\n\t\t */\r\n\r\n\t\tinitialise() {\r\n\r\n\t\t\tthrow new Error(\"Test#initialise method not implemented!\");\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this test.\r\n\t\t *\r\n\t\t * @throws {Error} An error is thrown if the method is not overridden.\r\n\t\t * @return {Test} This test.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthrow new Error(\"Test#clear method not implemented!\");\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Runs this test.\r\n\t\t *\r\n\t\t * @throws {Error} An error is thrown if the method is not overridden.\r\n\t\t * @return {String} A result message.\r\n\t\t */\r\n\r\n\t\trun() {\r\n\r\n\t\t\tthrow new Error(\"Test#run method not implemented!\");\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A compression test.\r\n\t */\r\n\r\n\tclass CompressionTest extends Test {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new compression test.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tsuper(\"Compression Test\");\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of Hermite data.\r\n\t\t\t *\r\n\t\t\t * @type {HermiteData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A target container for compressed Hermite data.\r\n\t\t\t *\r\n\t\t\t * @type {HermiteData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.targetContainer = new HermiteData(false);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Initialises test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {CompressionTest} This test.\r\n\t\t */\r\n\r\n\t\tinitialise() {\r\n\r\n\t\t\tconst cellSize = 1;\r\n\t\t\tconst halfSize = cellSize / 2;\r\n\t\t\tconst scale = halfSize - 0.075;\r\n\t\t\tconst cellPosition = [-halfSize, -halfSize, -halfSize];\r\n\r\n\t\t\tconst sdf = SuperPrimitive.create(SuperPrimitivePreset.PIPE);\r\n\t\t\tsdf.origin.set(0, 0, 0);\r\n\t\t\tsdf.setScale(scale);\r\n\r\n\t\t\tHermiteData.resolution = 64;\r\n\r\n\t\t\tthis.data = ConstructiveSolidGeometry.run(cellPosition, cellSize, null, sdf.setOperationType(OperationType.UNION));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {CompressionTest} This test.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.data = null;\r\n\t\t\tthis.targetContainer.clear();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Runs this test.\r\n\t\t *\r\n\t\t * @return {Report} A report.\r\n\t\t */\r\n\r\n\t\trun() {\r\n\r\n\t\t\tconst c = 1000;\r\n\r\n\t\t\tconst report = new Report(\"Compression Report\");\r\n\t\t\tconst targetContainer = this.targetContainer;\r\n\t\t\tconst data = this.data;\r\n\r\n\t\t\tconst n = HermiteData.resolution;\r\n\t\t\tconst maxMaterials = Math.pow((n + 1), 3);\r\n\t\t\tconst maxEdges = 3 * Math.pow((n + 1), 2) * n;\r\n\r\n\t\t\tlet edgeData;\r\n\t\t\tlet materials;\r\n\t\t\tlet materialCount;\r\n\t\t\tlet runLengthCount;\r\n\t\t\tlet edgeCount;\r\n\t\t\tlet t0, i;\r\n\r\n\t\t\treport.addLine(\"Performing \" + c + \" compression tasks\");\r\n\r\n\t\t\tfor(i = 0; i < c; ++i) {\r\n\r\n\t\t\t\tt0 = performance.now();\r\n\t\t\t\tdata.compress(targetContainer);\r\n\t\t\t\treport.addValue(performance.now() - t0);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterials = targetContainer.materials;\r\n\t\t\tmaterialCount = targetContainer.materialIndices.length;\r\n\t\t\trunLengthCount = targetContainer.runLengths.length;\r\n\t\t\tedgeData = data.edgeData;\r\n\t\t\tedgeCount = (\r\n\t\t\t\tedgeData.indices[0].length +\r\n\t\t\t\tedgeData.indices[1].length +\r\n\t\t\t\tedgeData.indices[2].length\r\n\t\t\t);\r\n\r\n\t\t\treport.addLine(\"Data Grid Resolution: \" + n + \"\\n\");\r\n\r\n\t\t\treport.addLine(\"Material Statistics\");\r\n\t\t\treport.addLine(\"Total Materials: \" + maxMaterials + \" (\" + materials + \" solid)\");\r\n\t\t\treport.addLine(\"Compressed Materials: \" + materialCount + \" (+ \" + runLengthCount + \" run-lengths)\");\r\n\t\t\treport.addLine(\"Compression Ratio: \" + (maxMaterials / (materialCount + runLengthCount * 4)).toFixed(2));\r\n\t\t\treport.addLine(\"Space Savings: \" + ((1 - (materialCount + runLengthCount * 4) / maxMaterials) * 100).toFixed(2) + \"%\");\r\n\t\t\treport.addLine(\"Maximum Memory Usage: \" + ((maxMaterials * 8) / 8 / 1024).toFixed(2) + \" KB\");\r\n\t\t\treport.addLine(\"Estimated Memory Usage: \" + ((materialCount * 8 + runLengthCount * 32) / 8 / 1024).toFixed(2) + \" KB\\n\");\r\n\r\n\t\t\treport.addLine(\"Edge Data Statistics\");\r\n\t\t\treport.addLine(\"Total Edges: \" + edgeCount + \" (\" + maxEdges + \" max)\");\r\n\t\t\treport.addLine(\"Compression Ratio: \" + (maxEdges / edgeCount).toFixed(2));\r\n\t\t\treport.addLine(\"Space Savings: \" + ((1 - edgeCount / maxEdges) * 100).toFixed(2) + \"%\");\r\n\t\t\treport.addLine(\"Maximum Memory Usage: \" + ((maxEdges * 32 + maxEdges * 32 + 3 * maxEdges * 32) / 8 / 1024 / 1024).toFixed(2) + \" MB\");\r\n\t\t\treport.addLine(\"Estimated Memory Usage: \" + ((edgeCount * 32 + edgeCount * 32 + 3 * edgeCount * 32) / 8 / 1024).toFixed(2) + \" KB\");\r\n\r\n\t\t\tconsole.log(\"Compressed data\", targetContainer);\r\n\r\n\t\t\treturn report;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A decompression test.\r\n\t */\r\n\r\n\tclass DecompressionTest extends Test {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new decompression test.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tsuper(\"Decompression Test\");\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of Hermite data.\r\n\t\t\t *\r\n\t\t\t * @type {HermiteData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A target container for compressed Hermite data.\r\n\t\t\t *\r\n\t\t\t * @type {HermiteData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.targetContainer = new HermiteData(false);\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Initialises test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {DecompressionTest} This test.\r\n\t\t */\r\n\r\n\t\tinitialise() {\r\n\r\n\t\t\tconst cellSize = 1;\r\n\t\t\tconst halfSize = cellSize / 2;\r\n\t\t\tconst scale = halfSize - 0.075;\r\n\t\t\tconst cellPosition = [-halfSize, -halfSize, -halfSize];\r\n\r\n\t\t\tconst sdf = SuperPrimitive.create(SuperPrimitivePreset.PIPE);\r\n\t\t\tsdf.origin.set(0, 0, 0);\r\n\t\t\tsdf.setScale(scale);\r\n\r\n\t\t\tHermiteData.resolution = 64;\r\n\r\n\t\t\tthis.data = ConstructiveSolidGeometry.run(cellPosition, cellSize, null, sdf.setOperationType(OperationType.UNION));\r\n\t\t\tthis.data.compress();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {DecompressionTest} This test.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.data = null;\r\n\t\t\tthis.targetContainer.clear();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Runs this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t */\r\n\r\n\t\trun() {\r\n\r\n\t\t\tconst c = 1000;\r\n\r\n\t\t\tconst report = new Report(\"Decompression Report\");\r\n\t\t\tconst targetContainer = this.targetContainer;\r\n\t\t\tconst data = this.data;\r\n\r\n\t\t\tlet t0, i;\r\n\r\n\t\t\treport.addLine(\"Performing \" + c + \" decompression tasks\");\r\n\r\n\t\t\tfor(i = 0; i < c; ++i) {\r\n\r\n\t\t\t\tt0 = performance.now();\r\n\t\t\t\tdata.decompress(targetContainer);\r\n\t\t\t\treport.addValue(performance.now() - t0);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.log(\"Decompressed data\", targetContainer);\r\n\r\n\t\t\treturn report;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A CSG test.\r\n\t */\r\n\r\n\tclass CSGTest extends Test {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new CSG test.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tsuper(\"CSG Test\");\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of Hermite data.\r\n\t\t\t *\r\n\t\t\t * @type {HermiteData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A cell size.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.cellSize = 1;\r\n\r\n\t\t\t/**\r\n\t\t\t * A cell position.\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.cellPosition = [-0.5, -0.5, -0.5];\r\n\r\n\t\t\t/**\r\n\t\t\t * An SDF.\r\n\t\t\t *\r\n\t\t\t * @type {SignedDistanceFunction}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.sdf = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Initialises test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {CSGTest} This test.\r\n\t\t */\r\n\r\n\t\tinitialise() {\r\n\r\n\t\t\tconst scale = (this.cellSize / 2) - 0.075;\r\n\t\t\tconst sdf0 = SuperPrimitive.create(SuperPrimitivePreset.PELLET).setOperationType(OperationType.UNION);\r\n\t\t\tconst sdf1 = SuperPrimitive.create(SuperPrimitivePreset.PIPE).setOperationType(OperationType.UNION);\r\n\r\n\t\t\tsdf0.origin.set(0, 0, 0);\r\n\t\t\tsdf1.origin.set(0, 0, 0);\r\n\t\t\tsdf0.setScale(scale);\r\n\t\t\tsdf1.setScale(scale);\r\n\r\n\t\t\tHermiteData.resolution = 64;\r\n\r\n\t\t\tthis.data = ConstructiveSolidGeometry.run(this.cellPosition, this.cellSize, null, sdf0);\r\n\t\t\tthis.sdf = sdf1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {CSGTest} This test.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.data = null;\r\n\t\t\tthis.sdf = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Runs this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t */\r\n\r\n\t\trun() {\r\n\r\n\t\t\tconst c = 500;\r\n\r\n\t\t\tconst report = new Report(\"CSG Report\");\r\n\t\t\tconst cellPosition = this.cellPosition;\r\n\t\t\tconst cellSize = this.cellSize;\r\n\t\t\tconst data = this.data;\r\n\t\t\tconst sdf = this.sdf;\r\n\r\n\t\t\tlet result, t0, i;\r\n\r\n\t\t\treport.addLine(\"Executing \" + c + \" CSG Union operations on existing data\");\r\n\t\t\treport.addLine(\"Initial material count: \" + data.materials);\r\n\t\t\treport.addLine(\"Initial edge count: \" + (\r\n\t\t\t\tdata.edgeData.indices[0].length +\r\n\t\t\t\tdata.edgeData.indices[1].length +\r\n\t\t\t\tdata.edgeData.indices[2].length\r\n\t\t\t));\r\n\r\n\t\t\tfor(i = 0; i < c; ++i) {\r\n\r\n\t\t\t\tt0 = performance.now();\r\n\t\t\t\tresult = ConstructiveSolidGeometry.run(cellPosition, cellSize, data, sdf);\r\n\t\t\t\treport.addValue(performance.now() - t0);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treport.addLine(\"Final material count: \" + result.materials);\r\n\t\t\treport.addLine(\"Final edge count: \" + (\r\n\t\t\t\tresult.edgeData.indices[0].length +\r\n\t\t\t\tresult.edgeData.indices[1].length +\r\n\t\t\t\tresult.edgeData.indices[2].length\r\n\t\t\t));\r\n\r\n\t\t\tconsole.log(\"Generated data\", result);\r\n\r\n\t\t\treturn report;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A SVO test.\r\n\t */\r\n\r\n\tclass SVOTest extends Test {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new SVO test.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tsuper(\"SVO Test\");\r\n\r\n\t\t\t/**\r\n\t\t\t * A set of Hermite data.\r\n\t\t\t *\r\n\t\t\t * @type {HermiteData}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.data = null;\r\n\r\n\t\t\t/**\r\n\t\t\t * A cell size.\r\n\t\t\t *\r\n\t\t\t * @type {Number}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.cellSize = 1;\r\n\r\n\t\t\t/**\r\n\t\t\t * A cell position.\r\n\t\t\t *\r\n\t\t\t * @type {Number[]}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.cellPosition = [-0.5, -0.5, -0.5];\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Initialises test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {SVOTest} This test.\r\n\t\t */\r\n\r\n\t\tinitialise() {\r\n\r\n\t\t\tconst scale = (this.cellSize / 2) - 0.075;\r\n\t\t\tconst sdf = SuperPrimitive.create(SuperPrimitivePreset.PIPE);\r\n\t\t\tsdf.origin.set(0, 0, 0);\r\n\t\t\tsdf.setScale(scale);\r\n\r\n\t\t\tHermiteData.resolution = 64;\r\n\t\t\t// VoxelCell.errorThreshold = 1.0;\r\n\r\n\t\t\tthis.data = ConstructiveSolidGeometry.run(this.cellPosition, this.cellSize, null, sdf.setOperationType(OperationType.UNION));\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {SVOTest} This test.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.data = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Runs this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t */\r\n\r\n\t\trun() {\r\n\r\n\t\t\tconst c = 200;\r\n\r\n\t\t\tconst report = new Report(\"SVO Report\");\r\n\t\t\tconst cellPosition = this.cellPosition;\r\n\t\t\tconst cellSize = this.cellSize;\r\n\t\t\tconst data = this.data;\r\n\r\n\t\t\tlet svo, t0, i;\r\n\r\n\t\t\treport.addLine(\"Building \" + c + \" sparse voxel octrees\");\r\n\t\t\treport.addLine(\"Material count: \" + data.materials);\r\n\t\t\treport.addLine(\"Edge count: \" + (\r\n\t\t\t\tdata.edgeData.indices[0].length +\r\n\t\t\t\tdata.edgeData.indices[1].length +\r\n\t\t\t\tdata.edgeData.indices[2].length\r\n\t\t\t));\r\n\r\n\t\t\tfor(i = 0; i < c; ++i) {\r\n\r\n\t\t\t\tt0 = performance.now();\r\n\t\t\t\tsvo = new SparseVoxelOctree(data, cellPosition, cellSize);\r\n\t\t\t\treport.addValue(performance.now() - t0);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treport.addLine(\"Final voxel count: \" + svo.voxelCount);\r\n\r\n\t\t\tconsole.log(\"Sparse voxel octree\", svo);\r\n\r\n\t\t\treturn report;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A contouring test.\r\n\t */\r\n\r\n\tclass ContouringTest extends Test {\r\n\r\n\t\t/**\r\n\t\t * Constructs a new contouring test.\r\n\t\t */\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tsuper(\"Contouring Test\");\r\n\r\n\t\t\t/**\r\n\t\t\t * A sparse voxel octree.\r\n\t\t\t *\r\n\t\t\t * @type {SparseVoxelOctree}\r\n\t\t\t * @private\r\n\t\t\t */\r\n\r\n\t\t\tthis.svo = null;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Initialises test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {ContouringTest} This test.\r\n\t\t */\r\n\r\n\t\tinitialise() {\r\n\r\n\t\t\tconst cellSize = 1;\r\n\t\t\tconst cellPosition = [-0.5, -0.5, -0.5];\r\n\t\t\tconst scale = (cellSize / 2) - 0.075;\r\n\t\t\tconst sdf = SuperPrimitive.create(SuperPrimitivePreset.PIPE);\r\n\t\t\tsdf.origin.set(0, 0, 0);\r\n\t\t\tsdf.setScale(scale);\r\n\r\n\t\t\tHermiteData.resolution = 64;\r\n\t\t\tVoxelCell.errorThreshold = 1.0;\r\n\r\n\t\t\tthis.svo = new SparseVoxelOctree(\r\n\t\t\t\tConstructiveSolidGeometry.run(cellPosition, cellSize, null, sdf.setOperationType(OperationType.UNION)),\r\n\t\t\t\tcellPosition, cellSize\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clears this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t * @return {ContouringTest} This test.\r\n\t\t */\r\n\r\n\t\tclear() {\r\n\r\n\t\t\tthis.svo = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Runs this test.\r\n\t\t *\r\n\t\t * @return {String} A result message.\r\n\t\t */\r\n\r\n\t\trun() {\r\n\r\n\t\t\tconst c = 500;\r\n\r\n\t\t\tconst report = new Report(\"Contouring Report\");\r\n\t\t\tconst svo = this.svo;\r\n\r\n\t\t\tlet isosurface, t0, i;\r\n\r\n\t\t\treport.addLine(\"Performing \" + c + \" contouring tasks\");\r\n\t\t\treport.addLine(\"Voxel count: \" + svo.voxelCount);\r\n\r\n\t\t\tfor(i = 0; i < c; ++i) {\r\n\r\n\t\t\t\tt0 = performance.now();\r\n\t\t\t\tisosurface = DualContouring.run(svo);\r\n\t\t\t\treport.addValue(performance.now() - t0);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treport.addLine(\"Generated vertices: \" + isosurface.positions.length);\r\n\t\t\treport.addLine(\"Generated triangle indices: \" + isosurface.indices.length);\r\n\r\n\t\t\tconsole.log(\"Extracted isosurface\", isosurface);\r\n\r\n\t\t\treturn report;\r\n\r\n\t\t}\r\n\r\n\t}\n\n\t/**\r\n\t * A collection of available tests.\r\n\t *\r\n\t * @type {Map}\r\n\t * @private\r\n\t * @final\r\n\t */\r\n\r\n\tconst tests = new Map([\r\n\t\t[\"Compression\", new CompressionTest()],\r\n\t\t[\"Decompression\", new DecompressionTest()],\r\n\t\t[\"Contouring\", new ContouringTest()],\r\n\t\t[\"CSG\", new CSGTest()],\r\n\t\t[\"SVO\", new SVOTest()]\r\n\t]);\r\n\r\n\t/**\r\n\t * Receives and handles messages from the main thread.\r\n\t *\r\n\t * @private\r\n\t * @param {Event} event - A message event containing data from the main thread.\r\n\t */\r\n\r\n\tself.addEventListener(\"message\", function onMessage(event) {\r\n\r\n\t\tconst test = tests.get(event.data).initialise();\r\n\t\tconst report = test.run();\r\n\t\ttest.clear();\r\n\r\n\t\tpostMessage({\r\n\t\t\treportName: report.name,\r\n\t\t\treportURL: URL.createObjectURL(new Blob([report.toString()], { type: \"text/plain\" }))\r\n\t\t});\r\n\r\n\t});\n\n}());\n";

	/**
	 * An object URL that points to the worker program.
	 *
	 * @type {String}
	 * @private
	 */

	const workerURL = URL.createObjectURL(new Blob([workerCode], { type: "text/javascript" }));

	/**
	 * A worker.
	 *
	 * @type {Worker}
	 * @private
	 */

	let worker = null;

	/**
	 * A list of available tests.
	 *
	 * @type {String[]}
	 * @private
	 */

	const tests = [
		"Compression",
		"Decompression",
		"Contouring",
		"CSG",
		"SVO"
	];

	/**
	 * Runs the specified test.
	 *
	 * @private
	 * @param {Event} event - An event.
	 */

	function runTest(event) {

		const id = event.target.id;
		const h3 = document.createElement("h3");

		h3.appendChild(document.createTextNode("Running " + id + "\u2026"));
		document.getElementById("aside").appendChild(h3);
		document.getElementById("mask").removeAttribute("class");

		worker.postMessage(id);

	}

	/**
	 * Shows the result of test that has been completed.
	 *
	 * @private
	 * @param {Event} event - A worker message.
	 */

	function showResult(event) {

		const response = event.data;
		const div = document.createElement("div");
		const span = document.createElement("span");
		const a = document.createElement("a");

		a.href = response.reportURL;
		a.setAttribute("download", response.reportName + ".log");
		a.setAttribute("class", "report");
		a.appendChild(document.createTextNode("Report \u2b73"));

		span.appendChild(document.createTextNode("Test complete"));
		span.setAttribute("class", "status");
		span.appendChild(a);

		div.setAttribute("class", "result");
		div.appendChild(span);
		div.appendChild(a);

		document.getElementById("aside").appendChild(div);
		document.getElementById("mask").setAttribute("class", "hidden");

	}

	/**
	 * Creates a list of available tests.
	 *
	 * @private
	 */

	function showAvailableTests() {

		const main = document.getElementById("main");
		const ul = document.createElement("ul");

		let test, li, a;

		for(test of tests) {

			li = document.createElement("li");

			a = document.createElement("a");
			a.appendChild(document.createTextNode(test));
			a.setAttribute("href", "#" + test);
			a.setAttribute("id", test);
			a.addEventListener("click", runTest);

			li.appendChild(a);
			ul.appendChild(li);

		}

		main.appendChild(ul);

	}

	/**
	 * Handles worker events.
	 *
	 * @param {Event} event - An event.
	 */

	function handleEvent(event) {

		switch(event.type) {

			case "message":
				showResult(event);
				break;

			case "error":
				console.error("Encountered an unexpected error", event);
				break;

		}

	}

	/**
	 * Starts the program.
	 *
	 * @private
	 * @param {Event} event - An event.
	 */

	window.addEventListener("load", function main(event) {

		const id = window.location.hash.slice(1);
		window.removeEventListener("load", main);

		// Initialise the worker thread.
		worker = new Worker(workerURL);
		worker.addEventListener("message", handleEvent);
		worker.addEventListener("error", handleEvent);

		showAvailableTests();

		if(tests.indexOf(id) !== -1) {

			runTest(id);

		}

	});

}());
